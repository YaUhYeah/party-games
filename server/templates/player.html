<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Play Game - Party Games Hub</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
    <style>
        /* Mobile optimizations */
        * {
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
        }
        
        /* Prevent text selection */
        .no-select {
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
        
        /* Mobile-friendly canvas */
        .drawing-canvas {
            touch-action: none;
            width: 100%;
            max-width: 600px;
            height: auto;
            aspect-ratio: 4/3;
        }
        
        /* Mobile-friendly buttons */
        .game-button {
            min-height: 44px; /* iOS minimum tap target size */
            padding: 12px 20px;
            margin: 8px;
            border-radius: 8px;
            font-size: 16px;
            transition: transform 0.1s;
        }
        
        .game-button:active {
            transform: scale(0.95);
        }
        
        /* Responsive game area */
        @media (max-width: 640px) {
            .game-container {
                padding: 12px;
            }
            
            .drawing-tools {
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                background: rgba(255, 255, 255, 0.95);
                backdrop-filter: blur(10px);
                padding: 8px;
                z-index: 100;
                display: flex;
                justify-content: space-around;
                box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            }
            
            .tool-button {
                width: 40px;
                height: 40px;
                padding: 8px;
                border-radius: 50%;
            }
        }
        
        /* Smooth scrolling */
        .smooth-scroll {
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }
        
        /* Loading spinner optimization */
        @keyframes optimized-spin {
            to { transform: rotate(360deg); }
        }
        .optimized-spinner {
            animation: optimized-spin 1s linear infinite;
            will-change: transform;
        }
    </style>
</head>
<body>
    <!-- Debug Overlay -->
    <div id="debugOverlay" class="fixed top-0 right-0 bg-black/80 text-white p-4 m-4 rounded-lg text-sm font-mono max-w-xs overflow-auto max-h-96 hidden z-50">
        <div class="flex justify-between items-center mb-2">
            <h3 class="font-bold">Debug Info</h3>
            <button onclick="window.gameState.toggleDebug()" class="text-gray-400 hover:text-white px-2">[X]</button>
        </div>
        <div class="text-xs mb-2">Press Ctrl+Shift+D to toggle</div>
        <pre id="debugInfo" class="whitespace-pre-wrap text-xs leading-tight"></pre>
    </div>

    <!-- Connection Status Toast -->
    <div id="connectionToast" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-black/80 text-white px-4 py-2 rounded-full text-sm hidden">
        <span id="connectionToastText"></span>
    </div>

    <div class="container mx-auto">
        <div class="game-container">
            <!-- Player Name Input -->
            <div id="nameInput" class="fixed inset-0 flex items-center justify-center bg-gradient-to-br from-indigo-500/90 to-purple-600/90 backdrop-blur-sm">
                <div class="bg-white p-8 rounded-2xl shadow-2xl max-w-md w-11/12 md:w-96 transform transition-all">
                    <h2 class="text-3xl font-bold text-indigo-600 mb-6">Join Game</h2>
                    <div id="connectionStatus" class="text-sm font-medium mb-4 transition-all">
                        <div class="flex items-center space-x-2 text-indigo-600">
                            <svg class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span>Connecting to server...</span>
                        </div>
                    </div>
                    <div id="roomInfo" class="text-sm bg-gray-100 p-3 rounded-lg mb-4 border border-gray-200">
                        <div class="flex justify-between items-center">
                            <span class="font-medium">Room Code:</span>
                            <span class="font-mono bg-white px-2 py-1 rounded border border-gray-200">{{ room_id }}</span>
                        </div>
                        <div class="mt-2 text-xs text-gray-500" id="roomStatus">
                            Checking room status...
                        </div>
                    </div>
                    
                    <!-- Status Messages -->
                    <div id="statusMessages" class="fixed bottom-4 left-1/2 transform -translate-x-1/2 w-11/12 max-w-md space-y-2 z-50">
                    </div>
                    <div class="space-y-6">
                        <div>
                            <label for="playerName" class="block text-sm font-medium text-gray-700 mb-1">Your Name</label>
                            <input type="text" id="playerName" 
                                   class="w-full p-3 border-2 border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 transition-all"
                                   placeholder="Enter your name"
                                   maxlength="20">
                            <p class="text-xs text-gray-500 mt-1">Maximum 20 characters</p>
                        </div>

                        <div class="profile-picture-section">
                            <label class="block text-sm font-medium text-gray-700 mb-3">Profile Picture</label>
                            <div class="profile-canvas-container relative bg-gray-50 rounded-xl p-4 border-2 border-dashed border-gray-300 hover:border-indigo-400 transition-all">
                                <canvas id="profileCanvas" 
                                        class="w-32 h-32 mx-auto bg-white rounded-full shadow-inner cursor-crosshair touch-none"
                                        width="128" height="128"></canvas>
                                
                                <div class="drawing-tools flex flex-col items-center mt-4 space-y-4">
                                    <!-- Color picker -->
                                    <div class="color-picker flex space-x-2">
                                        <button class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                style="background-color: #000000"
                                                onclick="window.gameState.setProfileColor('#000000')"></button>
                                        <button class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                style="background-color: #FF0000"
                                                onclick="window.gameState.setProfileColor('#FF0000')"></button>
                                        <button class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                style="background-color: #00FF00"
                                                onclick="window.gameState.setProfileColor('#00FF00')"></button>
                                        <button class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                style="background-color: #0000FF"
                                                onclick="window.gameState.setProfileColor('#0000FF')"></button>
                                    </div>

                                    <!-- Tool buttons -->
                                    <div class="tool-buttons flex space-x-2">
                                        <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                onclick="window.gameState.setProfileTool('brush')" title="Brush">
                                            <i class="fas fa-paint-brush text-gray-600 text-lg"></i>
                                        </button>
                                        <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                onclick="window.gameState.setProfileTool('eraser')" title="Eraser">
                                            <i class="fas fa-eraser text-gray-600 text-lg"></i>
                                        </button>
                                        <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                                                onclick="window.gameState.clearProfileCanvas()" title="Clear">
                                            <i class="fas fa-trash-alt text-gray-600 text-lg"></i>
                                        </button>
                                    </div>

                                    <!-- Size slider -->
                                    <div class="size-slider w-full px-2">
                                        <input type="range" 
                                               id="profileBrushSize" 
                                               min="1" 
                                               max="20" 
                                               value="4"
                                               oninput="window.gameState.setProfileBrushSize(this.value)"
                                               class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                                    </div>
                                </div>

                                <div class="text-xs text-gray-500 text-center mt-2">
                                    Draw your profile picture or tap to start
                                </div>
                            </div>
                        </div>

                        <button id="joinButton" type="button"
                                class="w-full bg-indigo-600 text-white p-4 rounded-xl hover:bg-indigo-700 active:bg-indigo-800 transition-all transform hover:scale-[1.02] flex items-center justify-center space-x-2">
                            <span class="join-text font-semibold">Join Game</span>
                            <span class="loading-spinner hidden">
                                <svg class="animate-spin h-5 w-5 text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                </svg>
                            </span>
                        </button>
                    </div>
                </div>
            </div>

            <!-- Game Area -->
            <div id="gameArea" class="hidden">
                <!-- Welcome Screen -->
                <div id="welcomeScreen" class="text-center py-8">
                    <h2 class="text-3xl font-bold text-indigo-600 mb-4">Welcome to Party Games!</h2>
                    <p class="text-gray-600 mb-8">Waiting for the host to start a game...</p>
                    <div class="flex flex-col items-center space-y-4">
                        <div class="bg-gray-100 p-4 rounded-lg">
                            <h3 class="font-semibold text-gray-700 mb-2">Players in Room</h3>
                            <div id="playerList" class="space-y-2"></div>
                        </div>
                    </div>
                </div>

                <!-- Game Screens -->
                <div id="triviaScreen" class="hidden">
                    <div class="max-w-2xl mx-auto">
                        <div class="bg-white rounded-xl shadow-lg p-6">
                            <div id="questionText" class="text-xl font-semibold mb-6"></div>
                            <div id="answerOptions" class="grid grid-cols-1 gap-4">
                                <!-- Answer buttons will be added here -->
                            </div>
                            <div id="timer" class="mt-4 text-center text-2xl font-bold"></div>
                            <div id="triviaFeedback" class="mt-4 text-center hidden">
                                <div class="correct-feedback text-green-500 hidden">
                                    <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <p class="text-xl font-bold">Correct!</p>
                                </div>
                                <div class="wrong-feedback text-red-500 hidden">
                                    <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <p class="text-xl font-bold">Wrong!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="chaseScreen" class="hidden">
                    <div class="max-w-2xl mx-auto">
                        <div class="bg-white rounded-xl shadow-lg p-6">
                            <div id="chaseInfo" class="text-center mb-4">
                                <div id="chaseRole" class="text-xl font-bold mb-2"></div>
                                <div id="chaseStatus" class="text-gray-600"></div>
                            </div>
                            <div id="chaseBoard" class="grid grid-cols-7 gap-2 mb-6">
                                <!-- Board positions will be added here -->
                            </div>
                            <div id="chaseQuestion" class="text-xl font-semibold mb-6"></div>
                            <div id="chaseOptions" class="grid grid-cols-1 gap-4">
                                <!-- Answer options will be added here -->
                            </div>
                            <div id="chaseTimer" class="mt-4 text-center text-2xl font-bold"></div>
                            <div id="chaseFeedback" class="mt-4 text-center hidden">
                                <div class="correct-feedback text-green-500 hidden">
                                    <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <p class="text-xl font-bold">Correct!</p>
                                </div>
                                <div class="wrong-feedback text-red-500 hidden">
                                    <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                                    </svg>
                                    <p class="text-xl font-bold">Wrong!</p>
                                </div>
                            </div>
                            <div id="chaseOptions" class="grid grid-cols-1 gap-4">
                                <!-- Answer buttons will be added here -->
                            </div>
                            <div id="chaseTimer" class="mt-4 text-center text-2xl font-bold"></div>
                            <div id="chaseFeedback" class="mt-4 text-center hidden">
                                <div class="catch-feedback text-red-500 hidden">
                                    <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"/>
                                    </svg>
                                    <p class="text-xl font-bold">Caught!</p>
                                </div>
                                <div class="escape-feedback text-green-500 hidden">
                                    <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                                    </svg>
                                    <p class="text-xl font-bold">Escaped!</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div id="drawingScreen" class="hidden">
                    <div class="max-w-2xl mx-auto">
                        <div class="bg-white rounded-xl shadow-lg p-6">
                            <div id="drawingPrompt" class="text-center mb-4">
                                <div id="drawingWord" class="text-2xl font-bold mb-2"></div>
                                <div id="drawingTurn" class="text-gray-600"></div>
                            </div>
                            <canvas id="drawingCanvas" class="drawing-canvas border-2 border-gray-200 rounded-lg mb-4"></canvas>
                            <div id="drawingTools" class="grid grid-cols-4 gap-4 mb-4">
                                <div class="col-span-3 grid grid-cols-3 gap-2">
                                    <!-- Color buttons -->
                                    <button class="color-btn w-10 h-10 rounded-full border-2 border-gray-300" style="background-color: #000000" data-color="#000000"></button>
                                    <button class="color-btn w-10 h-10 rounded-full border-2 border-gray-300" style="background-color: #FF0000" data-color="#FF0000"></button>
                                    <button class="color-btn w-10 h-10 rounded-full border-2 border-gray-300" style="background-color: #00FF00" data-color="#00FF00"></button>
                                    <button class="color-btn w-10 h-10 rounded-full border-2 border-gray-300" style="background-color: #0000FF" data-color="#0000FF"></button>
                                    <button class="color-btn w-10 h-10 rounded-full border-2 border-gray-300" style="background-color: #FFFF00" data-color="#FFFF00"></button>
                                    <button class="color-btn w-10 h-10 rounded-full border-2 border-gray-300" style="background-color: #FF00FF" data-color="#FF00FF"></button>
                                </div>
                                <div class="tool-buttons grid grid-cols-1 gap-2">
                                    <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300" data-tool="brush">
                                        <i class="fas fa-paint-brush"></i>
                                    </button>
                                    <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300" data-tool="eraser">
                                        <i class="fas fa-eraser"></i>
                                    </button>
                                    <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300" onclick="clearCanvas()">
                                        <i class="fas fa-trash"></i>
                                    </button>
                                </div>
                            </div>
                            <div class="flex items-center justify-between">
                                <div class="brush-size flex items-center space-x-2">
                                    <input type="range" id="brushSize" min="1" max="20" value="4" class="w-32">
                                    <span id="brushSizeValue" class="text-sm">4px</span>
                                </div>
                                <div id="drawingTimer" class="text-2xl font-bold"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Game Feedback -->
                <div id="gameFeedback" class="fixed inset-0 bg-black/80 hidden items-center justify-center">
                    <div class="bg-white rounded-xl p-8 max-w-md w-11/12 text-center">
                        <div id="feedbackIcon" class="mb-4">
                            <!-- Icon will be added here -->
                        </div>
                        <h3 id="feedbackTitle" class="text-2xl font-bold mb-2"></h3>
                        <p id="feedbackMessage" class="text-gray-600 mb-4"></p>
                        <div id="feedbackStats" class="grid grid-cols-2 gap-4 mb-6">
                            <!-- Stats will be added here -->
                        </div>
                        <button id="feedbackButton" class="bg-indigo-600 text-white px-6 py-3 rounded-lg w-full">
                            Continue
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialize game state
        const gameState = {
            socket: null,
            roomId: "{{ room_id }}",
            hasJoined: false,
            debugVisible: false,
            currentGame: null,
            isDrawer: false,
            isChaser: false,
            debugState: {
                socketConnected: false,
                lastError: null,
                joinAttempts: 0,
                events: []
            },

            // Initialize socket connection
            initSocket() {
                console.log('Initializing socket connection...');
                this.socket = io({
                    query: { room_id: this.roomId },
                    transports: ['websocket'],
                    upgrade: false,
                    reconnection: true,
                    reconnectionAttempts: 5
                });

                // Socket connection events
                this.socket.on('connect', () => {
                    console.log('Socket connected:', this.socket.id);
                    this.debugState.socketConnected = true;
                    this.updateDebugInfo();
                    this.showStatus('Connected to server', 'success');
                });

                this.socket.on('disconnect', () => {
                    console.log('Socket disconnected');
                    this.debugState.socketConnected = false;
                    this.updateDebugInfo();
                    this.showStatus('Disconnected from server', 'error');
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Socket connection error:', error);
                    this.debugState.lastError = error.message;
                    this.updateDebugInfo();
                    this.showStatus('Connection error: ' + error.message, 'error');
                });

                // Game events
                this.socket.on('join_confirmed', (data) => {
                    console.log('Join confirmed:', data);
                    
                    // Reset joining state
                    this.joiningInProgress = false;
                    
                    // Hide join screen and show game area
                    document.getElementById('nameInput').classList.add('hidden');
                    document.getElementById('gameArea').classList.remove('hidden');
                    document.getElementById('welcomeScreen').classList.remove('hidden');
                    
                    // Reset join button state
                    const joinButton = document.getElementById('joinButton');
                    const joinText = joinButton.querySelector('.join-text');
                    const loadingSpinner = joinButton.querySelector('.loading-spinner');
                    joinButton.disabled = false;
                    joinText.classList.remove('hidden');
                    loadingSpinner.classList.add('hidden');
                    
                    // Update game state
                    this.hasJoined = true;
                    this.roomId = data.room_id;
                    this.playerId = data.player_id;
                    
                    // Update player list
                    if (data.current_players) {
                        this.updatePlayerList(data.current_players);
                    }
                    
                    // Initialize game screens
                    this.initGameScreens();
                    
                    // Play join sound and show welcome message
                    playSound('player_join');
                    this.showStatus('Successfully joined the game!', 'success');
                    
                    // Save successful join to localStorage
                    localStorage.setItem('lastJoinedRoom', this.roomId);
                    
                    // Add reconnection handling
                    window.addEventListener('online', () => {
                        if (this.hasJoined && !this.socket.connected) {
                            this.showStatus('Reconnecting...', 'info');
                            this.socket.connect();
                        }
                    });
                    playSound('player_join');
                    this.updatePlayerList(data.current_players);
                });

                this.socket.on('join_error', (data) => {
                    console.error('Join error:', data);
                    this.showStatus(data.message, 'error');
                    const joinButton = document.getElementById('joinButton');
                    const joinText = joinButton.querySelector('.join-text');
                    const loadingSpinner = joinButton.querySelector('.loading-spinner');
                    joinButton.disabled = false;
                    joinText.classList.remove('hidden');
                    loadingSpinner.classList.add('hidden');
                });

                this.socket.on('player_joined', (data) => {
                    console.log('Player joined:', data);
                    this.updatePlayerList(data.players);
                    if (data.new_player) {
                        this.showStatus(`${data.new_player} joined the game`, 'info');
                        playSound('player_join');
                    }
                    
                    // Update scores if available
                    if (data.scores) {
                        this.updateScores(data.scores);
                    }
                });
                
                // Initialize chase game board
                initChaseBoard(size) {
                    const board = document.getElementById('chaseBoard');
                    if (!board) {
                        console.error('Chase board element not found');
                        return;
                    }
                    
                    board.innerHTML = '';
                    board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;
                    board.className = 'grid gap-2 w-full max-w-2xl mx-auto my-4';
                    
                    for (let i = 0; i < size; i++) {
                        const cell = document.createElement('div');
                        cell.id = `chase-cell-${i}`;
                        cell.className = 'aspect-square rounded-lg transition-all duration-300 shadow-md';
                        
                        // Add cell content and hover effects
                        if (i === 0) {
                            cell.className += ' bg-red-500 hover:bg-red-600'; // Start position
                            cell.innerHTML = '<i class="fas fa-flag-checkered text-white"></i>';
                        } else if (i === size - 1) {
                            cell.className += ' bg-green-500 hover:bg-green-600'; // End position
                            cell.innerHTML = '<i class="fas fa-trophy text-white"></i>';
                        } else {
                            cell.className += ' bg-gray-700 hover:bg-gray-600'; // Regular position
                        }
                        
                        board.appendChild(cell);
                    }
                    
                    // Add board legend
                    const legend = document.createElement('div');
                    legend.className = 'flex justify-center items-center space-x-4 text-sm mt-4';
                    legend.innerHTML = `
                        <div class="flex items-center">
                            <div class="w-4 h-4 rounded bg-red-600 mr-2"></div>
                            <span>Chaser</span>
                        </div>
                        <div class="flex items-center">
                            <div class="w-4 h-4 rounded bg-blue-500 mr-2"></div>
                            <span>Contestant</span>
                        </div>
                    `;
                    board.parentNode.appendChild(legend);
                },
                
                // Handle chase answer submission
                submitChaseAnswer(answerIndex) {
                    if (!this.socket || this.answerSubmitted) return;
                    
                    this.answerSubmitted = true;
                    this.socket.emit('chase_answer', {
                        room_id: this.roomId,
                        answer: answerIndex
                    });
                    
                    // Disable all answer buttons and show loading state
                    const options = document.getElementById('chaseOptions');
                    if (options) {
                        Array.from(options.children).forEach((button, index) => {
                            button.disabled = true;
                            if (index === answerIndex) {
                                button.classList.add('ring-2', 'ring-indigo-500', 'opacity-75');
                            } else {
                                button.classList.add('opacity-50');
                            }
                        });
                    }
                    
                    // Show answer submitted message
                    const statusDiv = document.getElementById('chaseStatus');
                    if (statusDiv) {
                        statusDiv.innerHTML += '<div class="text-sm text-indigo-600 mt-2">Answer submitted, waiting for other player...</div>';
                    }
                },
                
                // Update chase board positions with animations
                updateChasePositions(data) {
                    const board = document.getElementById('chaseBoard');
                    if (!board) return;
                    
                    // Reset all cells with transition
                    Array.from(board.children).forEach(cell => {
                        cell.className = 'aspect-square rounded-lg transition-all duration-300 bg-gray-700 hover:bg-gray-600';
                        cell.innerHTML = '';
                    });
                    
                    // Update start and end positions
                    const startCell = board.children[0];
                    const endCell = board.children[board.children.length - 1];
                    startCell.className = 'aspect-square rounded-lg transition-all duration-300 bg-red-500 hover:bg-red-600';
                    endCell.className = 'aspect-square rounded-lg transition-all duration-300 bg-green-500 hover:bg-green-600';
                    startCell.innerHTML = '<i class="fas fa-flag-checkered text-white"></i>';
                    endCell.innerHTML = '<i class="fas fa-trophy text-white"></i>';
                    
                    // Animate chaser position
                    if (data.chaser_position >= 0) {
                        const chaserCell = board.children[data.chaser_position];
                        chaserCell.className = 'aspect-square rounded-lg transition-all duration-300 bg-red-600 hover:bg-red-700 transform scale-110';
                        chaserCell.innerHTML = '<i class="fas fa-running text-white transform -scale-x-100"></i>';
                    }
                    
                    // Animate contestant position
                    if (data.contestant_position >= 0) {
                        const contestantCell = board.children[data.contestant_position];
                        contestantCell.className = 'aspect-square rounded-lg transition-all duration-300 bg-blue-500 hover:bg-blue-600 transform scale-110';
                        contestantCell.innerHTML = '<i class="fas fa-running text-white"></i>';
                    }
                    
                    // Update game status
                    const statusDiv = document.getElementById('chaseStatus');
                    if (statusDiv) {
                        let status = '';
                        const distance = data.chaser_position - data.contestant_position;
                        
                        if (distance === 1) {
                            status = '<div class="text-red-500 font-bold">The Chaser is right behind you!</div>';
                        } else if (distance > 1) {
                            status = `<div class="text-blue-500">You are ${distance} steps ahead of the Chaser</div>`;
                        }
                        
                        if (status) {
                            statusDiv.innerHTML += `<div class="mt-2">${status}</div>`;
                        }
                    }
                },
                
                // Setup trivia question
                setupTriviaQuestion(question) {
                    const questionText = document.getElementById('questionText');
                    const answerOptions = document.getElementById('answerOptions');
                    if (!questionText || !answerOptions) return;
                    
                    // Update question text
                    questionText.textContent = question.text;
                    
                    // Clear previous options
                    answerOptions.innerHTML = '';
                    
                    // Add answer buttons
                    question.options.forEach((option, index) => {
                        const button = document.createElement('button');
                        button.className = 'w-full p-4 text-left bg-white border-2 border-gray-200 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500 transition-all transform hover:scale-[1.01] active:scale-[0.99]';
                        button.innerHTML = `
                            <div class="flex items-center">
                                <span class="text-indigo-600 font-bold mr-3">${String.fromCharCode(65 + index)}.</span>
                                <span>${option}</span>
                            </div>
                        `;
                        button.onclick = () => this.submitAnswer(index);
                        answerOptions.appendChild(button);
                    });
                    
                    // Reset answer state
                    this.answerSubmitted = false;
                },
                
                // Setup chase game
                setupChaseGame(data) {
                    this.isChaser = data.is_chaser;
                    const chaseInfo = document.getElementById('chaseInfo');
                    if (chaseInfo) {
                        chaseInfo.innerHTML = `
                            <div class="text-xl font-bold mb-2">
                                ${data.is_chaser ? 'You are the Chaser!' : 'You are a Contestant!'}
                            </div>
                            <div class="text-gray-600">
                                Category: ${data.category || 'General Knowledge'}
                            </div>
                        `;
                    }
                    
                    // Initialize board
                    this.initChaseBoard(data.board_size || 7);
                    
                    // Reset game state
                    this.answerSubmitted = false;
                },
                
                // Show answer result
                showAnswerResult(data) {
                    const feedback = document.getElementById('triviaFeedback');
                    if (!feedback) return;
                    
                    // Show appropriate feedback
                    feedback.classList.remove('hidden');
                    const correctFeedback = feedback.querySelector('.correct-feedback');
                    const wrongFeedback = feedback.querySelector('.wrong-feedback');
                    
                    if (data.correct) {
                        correctFeedback.classList.remove('hidden');
                        wrongFeedback.classList.add('hidden');
                    } else {
                        correctFeedback.classList.add('hidden');
                        wrongFeedback.classList.remove('hidden');
                    }
                    
                    // Hide feedback after delay
                    setTimeout(() => {
                        feedback.classList.add('hidden');
                    }, 2000);
                },
                
                // Show game results
                showGameResults(data) {
                    // Create results overlay
                    const overlay = document.createElement('div');
                    overlay.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
                    overlay.innerHTML = `
                        <div class="bg-white rounded-xl p-8 max-w-md w-11/12 transform transition-all">
                            <h2 class="text-2xl font-bold text-center mb-6">Game Over!</h2>
                            <div class="space-y-4">
                                ${data.winner ? `
                                    <div class="text-center text-xl font-medium">
                                        Winner: ${data.winner}
                                    </div>
                                ` : ''}
                                <div class="bg-gray-100 rounded-lg p-4">
                                    <h3 class="font-semibold mb-2">Final Scores</h3>
                                    <div class="space-y-2">
                                        ${Object.entries(data.scores || {})
                                            .sort(([,a], [,b]) => b - a)
                                            .map(([name, score]) => `
                                                <div class="flex justify-between items-center">
                                                    <span class="font-medium">${name}</span>
                                                    <span class="text-gray-600">${score} points</span>
                                                </div>
                                            `).join('')}
                                    </div>
                                </div>
                                <button onclick="location.reload()" 
                                        class="w-full bg-indigo-600 text-white p-4 rounded-lg hover:bg-indigo-700 transition-all">
                                    Play Again
                                </button>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(overlay);
                },
                
                // Disable answer buttons
                disableAnswerButtons() {
                    const options = document.getElementById('answerOptions');
                    if (!options) return;
                    
                    Array.from(options.children).forEach(button => {
                        button.disabled = true;
                        button.classList.add('opacity-50', 'cursor-not-allowed');
                    });
                },
                
                // Profile drawing functionality
                initProfileDrawing() {
                    const canvas = document.getElementById('profileCanvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Set default styles
                    ctx.strokeStyle = '#000000';
                    ctx.lineWidth = 4;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    
                    // Fill with white
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Create circular mask
                    ctx.globalCompositeOperation = 'destination-in';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                    
                    // Drawing state
                    let isDrawing = false;
                    let lastX = 0;
                    let lastY = 0;
                    
                    // Get canvas-relative coordinates
                    function getCoords(e) {
                        const rect = canvas.getBoundingClientRect();
                        const scaleX = canvas.width / rect.width;
                        const scaleY = canvas.height / rect.height;
                        
                        if (e.touches) {
                            return {
                                x: (e.touches[0].clientX - rect.left) * scaleX,
                                y: (e.touches[0].clientY - rect.top) * scaleY
                            };
                        }
                        return {
                            x: (e.clientX - rect.left) * scaleX,
                            y: (e.clientY - rect.top) * scaleY
                        };
                    }
                    
                    // Drawing functions
                    function startDrawing(e) {
                        const coords = getCoords(e);
                        isDrawing = true;
                        [lastX, lastY] = [coords.x, coords.y];
                    }
                    
                    function draw(e) {
                        if (!isDrawing) return;
                        e.preventDefault();
                        
                        const coords = getCoords(e);
                        ctx.beginPath();
                        ctx.moveTo(lastX, lastY);
                        ctx.lineTo(coords.x, coords.y);
                        ctx.stroke();
                        
                        [lastX, lastY] = [coords.x, coords.y];
                    }
                    
                    function stopDrawing() {
                        isDrawing = false;
                    }
                    
                    // Event listeners
                    canvas.addEventListener('mousedown', startDrawing);
                    canvas.addEventListener('mousemove', draw);
                    canvas.addEventListener('mouseup', stopDrawing);
                    canvas.addEventListener('mouseout', stopDrawing);
                    
                    canvas.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        startDrawing(e);
                    });
                    
                    canvas.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        draw(e);
                    });
                    
                    canvas.addEventListener('touchend', stopDrawing);
                    canvas.addEventListener('touchcancel', stopDrawing);
                    
                    // Store canvas context in window.gameState
                    window.gameState.profileCtx = ctx;
                },
                
                // Profile drawing tools
                setProfileColor(color) {
                    if (!window.gameState.profileCtx) return;
                    window.gameState.profileCtx.strokeStyle = color;
                    window.gameState.profileCtx.globalCompositeOperation = 'source-over';
                    
                    // Update UI
                    document.querySelectorAll('.color-picker button').forEach(btn => {
                        btn.classList.toggle('ring-2', btn.style.backgroundColor === color);
                    });
                },
                
                setProfileTool(tool) {
                    if (!window.gameState.profileCtx) return;
                    if (tool === 'eraser') {
                        window.gameState.profileCtx.globalCompositeOperation = 'destination-out';
                    } else {
                        window.gameState.profileCtx.globalCompositeOperation = 'source-over';
                    }
                    
                    // Update UI
                    document.querySelectorAll('.tool-buttons button').forEach(btn => {
                        btn.classList.toggle('ring-2', btn.getAttribute('title').toLowerCase() === tool);
                    });
                },
                
                setProfileBrushSize(size) {
                    if (!window.gameState.profileCtx) return;
                    window.gameState.profileCtx.lineWidth = size;
                },
                
                clearProfileCanvas() {
                    const canvas = document.getElementById('profileCanvas');
                    const ctx = window.gameState.profileCtx;
                    if (!ctx) return;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // Fill with white
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    // Create circular mask
                    ctx.globalCompositeOperation = 'destination-in';
                    ctx.beginPath();
                    ctx.arc(canvas.width/2, canvas.height/2, canvas.width/2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalCompositeOperation = 'source-over';
                },
                
                // Helper function to update player list
                updatePlayerList(players) {
                    const playerList = document.getElementById('playerList');
                    if (!playerList) return;
                    
                    playerList.innerHTML = '';
                    players.forEach(player => {
                        const div = document.createElement('div');
                        div.className = 'flex justify-between items-center p-2 bg-white rounded-lg shadow-sm';
                        
                        // Create player info section
                        const playerInfo = document.createElement('div');
                        playerInfo.className = 'flex items-center space-x-2';
                        
                        // Profile picture or initial
                        const profilePic = document.createElement('div');
                        if (player.profile_picture) {
                            profilePic.className = 'w-8 h-8 rounded-full bg-indigo-100 overflow-hidden';
                            const img = document.createElement('img');
                            img.src = player.profile_picture;
                            img.className = 'w-full h-full object-cover';
                            profilePic.appendChild(img);
                        } else {
                            profilePic.className = 'w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center';
                            profilePic.innerHTML = `<span class="text-indigo-600 font-medium">${player.name[0].toUpperCase()}</span>`;
                        }
                        playerInfo.appendChild(profilePic);
                        
                        // Player name
                        const nameSpan = document.createElement('span');
                        nameSpan.className = 'font-medium';
                        nameSpan.textContent = player.name;
                        playerInfo.appendChild(nameSpan);
                        
                        div.appendChild(playerInfo);
                        
                        // Create stats section
                        const statsDiv = document.createElement('div');
                        statsDiv.className = 'flex items-center space-x-2';
                        
                        // Score
                        const scoreSpan = document.createElement('span');
                        scoreSpan.className = 'text-gray-500';
                        scoreSpan.textContent = `${player.score || 0} points`;
                        statsDiv.appendChild(scoreSpan);
                        
                        // Role indicator (if any)
                        if (player.is_chaser) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'text-red-500';
                            roleSpan.textContent = '(Chaser)';
                            statsDiv.appendChild(roleSpan);
                        } else if (player.is_drawer) {
                            const roleSpan = document.createElement('span');
                            roleSpan.className = 'text-blue-500';
                            roleSpan.textContent = '(Drawing)';
                            statsDiv.appendChild(roleSpan);
                        }
                        
                        div.appendChild(statsDiv);
                        playerList.appendChild(div);
                    });
                },
                
                // Load saved profile from localStorage
                loadSavedProfile() {
                    const savedPicture = localStorage.getItem('lastProfilePicture');
                    const savedName = localStorage.getItem('lastPlayerName');
                    
                    if (savedName) {
                        const nameInput = document.getElementById('playerName');
                        if (nameInput) nameInput.value = savedName;
                    }
                    
                    if (savedPicture) {
                        const canvas = document.getElementById('profileCanvas');
                        if (canvas) {
                            const ctx = canvas.getContext('2d');
                            const img = new Image();
                            img.onload = () => {
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                ctx.drawImage(img, 0, 0);
                            };
                            img.src = savedPicture;
                        }
                    }
                },

            // Show status messages
            showStatus(message, type = 'info', duration = 3000) {
                const statusMessages = document.getElementById('statusMessages');
                if (!statusMessages) return;
                
                const colors = {
                    success: 'bg-green-500',
                    error: 'bg-red-500',
                    info: 'bg-indigo-500',
                    warning: 'bg-yellow-500'
                };
                
                const alert = document.createElement('div');
                alert.className = `${colors[type]} text-white px-4 py-2 rounded-lg shadow-lg transform transition-all duration-300 opacity-0 translate-y-2`;
                alert.textContent = message;
                
                statusMessages.appendChild(alert);
                
                // Trigger animation
                requestAnimationFrame(() => {
                    alert.classList.remove('opacity-0', 'translate-y-2');
                });
                
                // Remove after duration
                setTimeout(() => {
                    alert.classList.add('opacity-0', 'translate-y-2');
                    setTimeout(() => {
                        statusMessages.removeChild(alert);
                    }, 300);
                }, duration);
            },
            
            // Play sound effects
            playSound(soundName) {
                const audio = new Audio(`/static/music/${soundName}.mp3`);
                audio.volume = 0.5;
                audio.play().catch(error => console.warn('Error playing sound:', error));
            },
            
            // Initialize the game
            init() {
                console.log('Initializing game with room ID:', this.roomId);
                
                // Initialize state
                this.joiningInProgress = false;
                this.answerSubmitted = false;
                this.currentGame = null;
                this.isChaser = false;
                this.isDrawer = false;
                this.hasJoined = false;
                
                // Initialize core components
                this.initSocket();
                this.initProfileDrawing();
                this.addKeyboardListeners();
                this.updateDebugInfo();
                
                // Check for existing session
                const lastJoinedRoom = localStorage.getItem('lastJoinedRoom');
                if (lastJoinedRoom === this.roomId) {
                    this.showStatus('Reconnecting to previous session...', 'info');
                }
                
                // Set initial drawing state
                this.setProfileColor('#000000');
                this.setProfileTool('brush');
                this.setProfileBrushSize(4);
                
                // Set up join button
                const joinButton = document.getElementById('joinButton');
                if (joinButton) {
                    joinButton.addEventListener('click', () => this.joinGame());
                } else {
                    console.error('Join button not found');
                }
                
                // Load saved profile if exists
                this.loadSavedProfile();
            },

            // Join the game
            async joinGame() {
                if (this.joiningInProgress) return;
                
                const playerName = document.getElementById('playerName').value.trim();
                if (!playerName) {
                    this.showStatus('Please enter your name', 'error');
                    return;
                }

                // Get profile picture from canvas
                const canvas = document.getElementById('profileCanvas');
                const profilePicture = canvas.toDataURL('image/png');

                // Show loading state
                const joinButton = document.getElementById('joinButton');
                const joinText = joinButton.querySelector('.join-text');
                const loadingSpinner = joinButton.querySelector('.loading-spinner');
                joinButton.disabled = true;
                joinText.classList.add('hidden');
                loadingSpinner.classList.remove('hidden');
                
                this.joiningInProgress = true;

                try {
                    // Save profile for future use
                    localStorage.setItem('lastProfilePicture', profilePicture);
                    localStorage.setItem('lastPlayerName', playerName);
                    
                    // Emit join event
                    this.socket.emit('join_room', {
                        room_id: this.roomId,
                        player_name: playerName,
                        profile_picture: profilePicture
                    });
                    
                    // Start a timeout to reset the button if no response
                    setTimeout(() => {
                        if (this.joiningInProgress) {
                            this.joiningInProgress = false;
                            joinButton.disabled = false;
                            joinText.classList.remove('hidden');
                            loadingSpinner.classList.add('hidden');
                            this.showStatus('Join request timed out. Please try again.', 'error');
                        }
                    }, 10000); // 10 second timeout
                } catch (error) {
                    console.error('Join error:', error);
                    this.showStatus(error.message || 'Failed to join game', 'error');
                    this.joiningInProgress = false;
                    joinButton.disabled = false;
                    joinText.classList.remove('hidden');
                    loadingSpinner.classList.add('hidden');
                }
            },

            // Add keyboard listeners
            addKeyboardListeners() {
                document.addEventListener('keydown', (e) => {
                    // Ctrl+Shift+D to toggle debug overlay
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        this.toggleDebug();
                    }
                });
            },

            // Toggle debug overlay
            toggleDebug() {
                const debugOverlay = document.getElementById('debugOverlay');
                this.debugVisible = !this.debugVisible;
                debugOverlay.classList.toggle('hidden', !this.debugVisible);
            },

            // Update debug info
            updateDebugInfo() {
                if (!this.debugVisible) return;
                const debugInfo = document.getElementById('debugInfo');
                if (!debugInfo) return;

                const info = {
                    roomId: this.roomId,
                    socketId: this.socket?.id,
                    connected: this.debugState.socketConnected,
                    lastError: this.debugState.lastError,
                    joinAttempts: this.debugState.joinAttempts,
                    hasJoined: this.hasJoined,
                    currentGame: this.currentGame,
                    events: this.debugState.events.slice(-5)
                };

                debugInfo.textContent = JSON.stringify(info, null, 2);
            },

            // Initialize game screens and event handlers
            initGameScreens() {
                if (!this.socket) {
                    console.error('Socket not initialized');
                    return;
                }

                // Socket event handlers for games
                // Game state updates
                this.socket.on('game_state', (data) => {
                    console.log('Game state update:', data);
                    this.currentGame = data.game_type;
                    
                    // Hide all game screens first
                    ['welcomeScreen', 'triviaScreen', 'chaseScreen', 'drawingScreen'].forEach(screen => {
                        const element = document.getElementById(screen);
                        if (element) element.classList.add('hidden');
                    });
                    
                    if (data.game_state === 'waiting') {
                        // Show welcome screen
                        document.getElementById('welcomeScreen').classList.remove('hidden');
                        this.showStatus('Waiting for other players...', 'info');
                        
                    } else if (data.game_state === 'playing') {
                        // Show appropriate game screen
                        if (data.game_type === 'trivia') {
                            document.getElementById('triviaScreen').classList.remove('hidden');
                            this.setupTriviaQuestion(data.question);
                            
                        } else if (data.game_type === 'chase') {
                            document.getElementById('chaseScreen').classList.remove('hidden');
                            this.setupChaseGame(data);
                            
                        } else if (data.game_type === 'drawing') {
                            document.getElementById('drawingScreen').classList.remove('hidden');
                            this.setupDrawingGame(data);
                        }
                        
                        // Play game start sound
                        this.playSound('round_start');
                        
                    } else if (data.game_state === 'complete') {
                        // Show game results
                        this.showGameResults(data);
                        
                        // Play game over sound
                        this.playSound('game_over');
                    }
                    
                    // Update debug info
                    this.updateDebugInfo();
                });
                
                // Game-specific events
                this.socket.on('question_timeout', () => {
                    this.showStatus('Time\'s up!', 'warning');
                    this.playSound('error');
                    this.disableAnswerButtons();
                });
                
                this.socket.on('answer_result', (data) => {
                    this.showAnswerResult(data);
                    this.playSound(data.correct ? 'correct' : 'wrong');
                });
                
                this.socket.on('chase_update', (data) => {
                    this.updateChasePositions(data);
                    if (data.caught) {
                        this.showStatus('The Chaser caught up!', 'error');
                        this.playSound('error');
                    } else if (data.escaped) {
                        this.showStatus('Successfully escaped!', 'success');
                        this.playSound('correct');
                    }
                });
                
                this.socket.on('drawing_update', (data) => {
                    if (!this.isDrawer) {
                        this.updateDrawingCanvas(data.drawing);
                    }
                });

                this.socket.on('game_started', (data) => {
                    console.log('Game started:', data);
                    this.currentGame = data.game_type;
                    this.gameState = data.game_state;
                    
                    // Show game area and hide name input
                    document.getElementById('nameInput').classList.add('hidden');
                    document.getElementById('gameArea').classList.remove('hidden');
                    document.getElementById('welcomeScreen').classList.add('hidden');
                    
                    // Hide all game screens
                    document.getElementById('triviaScreen').classList.add('hidden');
                    document.getElementById('chaseScreen').classList.add('hidden');
                    document.getElementById('drawingScreen').classList.add('hidden');
                    
                    // Show appropriate game screen
                    if (data.game_type === 'chase') {
                        document.getElementById('chaseScreen').classList.remove('hidden');
                        
                        // Update chase info
                        document.getElementById('chaseInfo').innerHTML = `
                            <div class="text-xl font-bold mb-2">
                                ${data.is_chaser ? 'You are the Chaser!' : 'You are a Contestant!'}
                            </div>
                            <div class="text-gray-600">
                                Category: ${data.chase_category}
                            </div>
                        `;
                        
                        // Initialize chase board
                        const board = document.getElementById('chaseBoard');
                        board.innerHTML = '';
                        board.style.gridTemplateColumns = `repeat(${data.board_size}, 1fr)`;
                        
                        for (let i = 0; i < data.board_size; i++) {
                            const cell = document.createElement('div');
                            cell.className = 'bg-gray-800 rounded-lg aspect-square';
                            cell.id = `chase-cell-${i}`;
                            board.appendChild(cell);
                        }
                        
                        // Play chase music
                        playMusic('chase');
                    } else if (data.game_type === 'trivia') {
                        document.getElementById('triviaScreen').classList.remove('hidden');
                        document.getElementById('questionText').textContent = data.question.question;
                        const options = document.getElementById('answerOptions');
                        options.innerHTML = '';
                        data.question.options.forEach(option => {
                            const button = document.createElement('button');
                            button.className = 'w-full p-4 text-left bg-white border-2 border-gray-200 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500';
                            button.textContent = option;
                            button.onclick = () => this.submitAnswer(option);
                            options.appendChild(button);
                        });
                    } else if (data.game_type === 'chase') {
                        document.getElementById('chaseScreen').classList.remove('hidden');
                        this.isChaser = data.is_chaser;
                        document.getElementById('chaseRole').textContent = data.is_chaser ? 'You are the Chaser!' : 'You are the Contestant!';
                        document.getElementById('chaseStatus').textContent = `Category: ${data.chase_category}`;
                        this.initChaseBoard(data.board_size);
                    } else if (data.game_type === 'chinese_whispers') {
                        document.getElementById('drawingScreen').classList.remove('hidden');
                        this.isDrawer = data.is_drawer;
                        if (data.is_drawer) {
                            document.getElementById('drawingWord').textContent = `Draw: ${data.word}`;
                            document.getElementById('drawingTurn').textContent = 'Your turn to draw!';
                            this.initDrawingCanvas();
                        } else {
                            document.getElementById('drawingWord').textContent = 'Waiting for drawing...';
                            document.getElementById('drawingTurn').textContent = 'Watch the drawing and guess the word';
                        }
                    }
                });

                this.socket.on('receive_drawing', (data) => {
                    if (!this.isDrawer) {
                        this.displayDrawing(data.drawing);
                    }
                });

                this.socket.on('next_player', (data) => {
                    document.getElementById('drawingTurn').textContent = `${data.player}'s turn`;
                });

                this.socket.on('round_complete', (data) => {
                    this.showFeedback({
                        title: 'Round Complete!',
                        message: `The word was: ${data.original_word}`,
                        stats: {
                            'Final Guess': data.final_guess,
                            'Your Score': data.scores[this.socket.id] || 0
                        }
                    });
                });

                // Chase game events
                this.socket.on('chase_question', (data) => {
                    const questionEl = document.getElementById('chaseQuestion');
                    const optionsEl = document.getElementById('chaseOptions');
                    
                    // Update question
                    questionEl.textContent = data.question;
                    
                    // Update options
                    optionsEl.innerHTML = '';
                    data.options.forEach((option, index) => {
                        const button = document.createElement('button');
                        button.className = 'w-full p-4 text-left bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors';
                        button.innerHTML = `
                            <span class="inline-block w-8 h-8 mr-3 text-center leading-8 bg-indigo-100 text-indigo-700 rounded-full font-bold">
                                ${String.fromCharCode(65 + index)}
                            </span>
                            ${option}
                        `;
                        button.onclick = () => this.submitChaseAnswer(index);
                        optionsEl.appendChild(button);
                    });
                    
                    // Start timer
                    if (data.time_limit) {
                        this.startTimer(data.time_limit);
                    }
                });
                
                this.socket.on('chase_answer_result', (data) => {
                    // Show feedback
                    const feedback = document.getElementById('chaseFeedback');
                    const correct = feedback.querySelector('.correct-feedback');
                    const wrong = feedback.querySelector('.wrong-feedback');
                    
                    feedback.classList.remove('hidden');
                    if (data.is_correct) {
                        correct.classList.remove('hidden');
                        wrong.classList.add('hidden');
                        playSound('correct');
                    } else {
                        correct.classList.add('hidden');
                        wrong.classList.remove('hidden');
                        playSound('wrong');
                    }
                    
                    // Update positions
                    this.updateChasePositions(data);
                    
                    // Show next question if available
                    if (data.next_question) {
                        setTimeout(() => {
                            feedback.classList.add('hidden');
                            this.socket.emit('ready_for_question', {
                                room_id: this.roomId
                            });
                        }, 2000);
                    }
                });
                
                this.socket.on('chase_game_over', (data) => {
                    this.showGameResults(data);
                });
                
                this.socket.on('game_complete', (data) => {
                    console.log('Game complete:', data);
                    this.showGameResults(data);
                });
                
                showGameResults(data) {
                    // Create results overlay
                    const overlay = document.createElement('div');
                    overlay.className = 'fixed inset-0 bg-black/80 flex items-center justify-center z-50';
                    
                    const content = document.createElement('div');
                    content.className = 'bg-white rounded-xl p-8 max-w-2xl w-11/12 transform transition-all';
                    
                    // Build results content
                    let resultsHTML = `
                        <h2 class="text-3xl font-bold text-center mb-6">${data.title || 'Game Results'}</h2>
                        <div class="space-y-6">
                    `;
                    
                    // Add game-specific results
                    if (this.currentGame === 'chase') {
                        const isChaser = data.chaser_id === this.socket.id;
                        const escaped = data.escaped_players?.includes(this.socket.id);
                        
                        resultsHTML += `
                            <div class="text-center text-xl mb-4">
                                ${isChaser ? 
                                    (data.chaser_won ? 'You caught all contestants!' : 'Some contestants escaped!') :
                                    (escaped ? 'You escaped with your prize money!' : 'The Chaser caught you!')}
                            </div>
                            <div class="text-center text-2xl font-bold mb-6">
                                ${isChaser ? 
                                    `Caught ${data.caught_count} contestants` :
                                    (escaped ? `Won ${data.prize_money} points!` : 'Better luck next time!')}
                            </div>
                            <div class="grid gap-4">
                                ${Object.entries(data.final_scores)
                                    .sort(([,a], [,b]) => b - a)
                                    .map(([player, score]) => `
                                        <div class="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                                            <span class="font-medium">${player}</span>
                                            <span class="text-lg">${score} points</span>
                                        </div>
                                    `).join('')}
                            </div>
                        `;
                    }
                    
                    // Add continue button
                    resultsHTML += `
                        </div>
                        <div class="mt-8 flex justify-center">
                            <button onclick="this.closest('.fixed').remove()" 
                                    class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700 transition-colors">
                                Continue
                            </button>
                        </div>
                    `;
                    
                    content.innerHTML = resultsHTML;
                    overlay.appendChild(content);
                    document.body.appendChild(overlay);
                    
                    // Play appropriate sound
                    if (data.chaser_won) {
                        playMusic('game_over');
                    } else {
                        playMusic('victory');
                    }
                },
                            'Your Score': data.final_scores[this.socket.id] || 0,
                            'Best Score': Math.max(...Object.values(data.final_scores))
                        }
                    });
                });
            },

            // Show feedback overlay
            showFeedback(data) {
                const feedback = document.getElementById('gameFeedback');
                const title = document.getElementById('feedbackTitle');
                const message = document.getElementById('feedbackMessage');
                const stats = document.getElementById('feedbackStats');
                const button = document.getElementById('feedbackButton');

                title.textContent = data.title;
                message.textContent = data.message;
                
                stats.innerHTML = '';
                Object.entries(data.stats).forEach(([key, value]) => {
                    const stat = document.createElement('div');
                    stat.className = 'bg-gray-50 p-3 rounded-lg';
                    stat.innerHTML = `
                        <div class="text-sm text-gray-500">${key}</div>
                        <div class="text-lg font-bold">${value}</div>
                    `;
                    stats.appendChild(stat);
                });

                feedback.classList.remove('hidden');
                feedback.classList.add('flex');

                button.onclick = () => {
                    feedback.classList.add('hidden');
                    feedback.classList.remove('flex');
                };
            },
            
            showStatus(message, type = 'info') {
                const statusContainer = document.getElementById('statusMessages');
                const status = document.createElement('div');
                status.className = `p-3 rounded-lg shadow-lg text-sm transition-all transform translate-y-2 ${
                    type === 'error' ? 'bg-red-500 text-white' :
                    type === 'success' ? 'bg-green-500 text-white' :
                    'bg-black/80 text-white'
                }`;
                status.textContent = message;
                statusContainer.appendChild(status);
                
                // Animate in
                requestAnimationFrame(() => {
                    status.style.transform = 'translateY(0)';
                });

                // Remove after delay
                setTimeout(() => {
                    status.style.opacity = '0';
                    setTimeout(() => status.remove(), 300);
                }, 3000);
            },

            initProfileDrawing() {
                console.log('Initializing profile drawing');
                const canvas = document.getElementById('profileCanvas');
                if (!canvas) {
                    console.error('Canvas element not found');
                    this.showStatus('Error initializing drawing canvas', 'error');
                    return;
                }

                // Show drawing guide
                this.showStatus('Tap and drag to draw your profile picture', 'info');

                // Set canvas size explicitly
                canvas.width = 128;
                canvas.height = 128;
                
                // Initialize drawing state
                this.isDrawing = false;
                this.currentColor = '#000000';
                this.currentTool = 'brush';
                this.brushSize = 4;
                this.lastX = 0;
                this.lastY = 0;
                
                // Get context
                const ctx = canvas.getContext('2d');
                
                // Set initial canvas state
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Store in state
                this.profileState = {
                    canvas,
                    ctx,
                    undoStack: [],
                    redoStack: []
                };

                // Add mouse events
                canvas.addEventListener('mousedown', this.handleDrawStart.bind(this));
                canvas.addEventListener('mousemove', this.handleDrawMove.bind(this));
                canvas.addEventListener('mouseup', this.handleDrawEnd.bind(this));
                canvas.addEventListener('mouseleave', this.handleDrawEnd.bind(this));

                // Add touch events
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    this.handleDrawStart({ offsetX: x, offsetY: y });
                });

                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const y = touch.clientY - rect.top;
                    this.handleDrawMove({ offsetX: x, offsetY: y });
                });

                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.handleDrawEnd();
                });

                // Initialize color buttons
                document.querySelectorAll('.color-picker button').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.currentColor = btn.dataset.color;
                        this.updateToolStyles();
                    });
                });

                // Initialize tool buttons
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    if (btn.dataset.tool) {
                        btn.addEventListener('click', () => {
                            this.currentTool = btn.dataset.tool;
                            this.updateToolStyles();
                        });
                    }
                });

                console.log('Drawing initialization complete');

                // Initialize canvas with white background
                this.profileState.ctx.fillStyle = '#FFFFFF';
                this.profileState.ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Enable touch action
                canvas.style.touchAction = 'none';
                
                // Add visual feedback for touch
                canvas.addEventListener('touchstart', () => {
                    canvas.style.transform = 'scale(0.98)';
                }, { passive: true });
                
                canvas.addEventListener('touchend', () => {
                    canvas.style.transform = 'scale(1)';
                }, { passive: true });
                
                // Initialize canvas
                this.profileState.ctx.fillStyle = '#FFFFFF';
                this.profileState.ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Save initial state
                this.saveProfileState();
                
                // Add event listeners
                canvas.addEventListener('mousedown', this.startProfileDrawing.bind(this));
                canvas.addEventListener('mousemove', this.drawProfile.bind(this));
                canvas.addEventListener('mouseup', this.endProfileDrawing.bind(this));
                canvas.addEventListener('mouseleave', this.endProfileDrawing.bind(this));
                
                // Enhanced touch events with scaling
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (touch.clientX - rect.left) * scaleX;
                    const y = (touch.clientY - rect.top) * scaleY;
                    this.isDrawing = true;
                    this.startProfileDrawing({ offsetX: x, offsetY: y });
                }, { passive: false });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (!this.isDrawing) return;
                    const touch = e.touches[0];
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;
                    const x = (touch.clientX - rect.left) * scaleX;
                    const y = (touch.clientY - rect.top) * scaleY;
                    this.drawProfile({ offsetX: x, offsetY: y });
                }, { passive: false });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.isDrawing = false;
                    this.endProfileDrawing();
                }, { passive: false });

                canvas.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    this.isDrawing = false;
                    this.endProfileDrawing();
                }, { passive: false });
                
                // Color picker
                const colorButtons = document.querySelectorAll('.color-picker button');
                colorButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.profileState.currentColor = btn.dataset.color;
                        this.updateToolStyles();
                    });
                });
                
                // Tool buttons
                const toolButtons = document.querySelectorAll('.tool-btn[data-tool]');
                toolButtons.forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.profileState.currentTool = btn.dataset.tool;
                        this.updateToolStyles();
                    });
                });
                
                // Brush size
                const sizeSlider = document.getElementById('brushSize');
                if (sizeSlider) {
                    sizeSlider.addEventListener('input', (e) => {
                        this.profileState.brushSize = parseInt(e.target.value);
                    });
                }
                
                this.updateToolStyles();
            },
            
            startProfileDrawing(e) {
                if (!this.profileState) return;
                const { ctx } = this.profileState;
                
                // Get coordinates, handling both mouse and touch events
                let x, y;
                if (e.touches) {
                    const rect = this.profileState.canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    x = (touch.clientX - rect.left) * (this.profileState.canvas.width / rect.width);
                    y = (touch.clientY - rect.top) * (this.profileState.canvas.height / rect.height);
                } else {
                    x = e.offsetX;
                    y = e.offsetY;
                }
                
                this.profileState.isDrawing = true;
                this.profileState.lastX = x;
                this.profileState.lastY = y;
                
                // Start new path
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                // Draw initial point for better touch response
                ctx.arc(x, y, this.profileState.brushSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Save state for undo
                this.saveProfileState();
                
                // Provide haptic feedback if available
                if (window.navigator.vibrate) {
                    window.navigator.vibrate(50);
                }
            },
            
            drawProfile(e) {
                if (!this.profileState || !this.profileState.isDrawing) return;
                
                const { ctx, currentColor, currentTool, brushSize, canvas } = this.profileState;
                
                // Get coordinates, handling both mouse and touch events
                let x, y;
                if (e.touches) {
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    x = (touch.clientX - rect.left) * (canvas.width / rect.width);
                    y = (touch.clientY - rect.top) * (canvas.height / rect.height);
                } else {
                    x = e.offsetX;
                    y = e.offsetY;
                }
                
                // Set drawing styles
                ctx.lineWidth = brushSize;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                if (currentTool === 'eraser') {
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.globalCompositeOperation = 'destination-out';
                } else {
                    ctx.strokeStyle = currentColor;
                    ctx.fillStyle = currentColor;
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                // Draw smooth line using quadratic curve
                ctx.beginPath();
                ctx.moveTo(this.profileState.lastX, this.profileState.lastY);
                
                // Calculate control point for smooth curve
                const cx = (this.profileState.lastX + x) / 2;
                const cy = (this.profileState.lastY + y) / 2;
                ctx.quadraticCurveTo(cx, cy, x, y);
                ctx.stroke();
                
                // Update last position
                this.profileState.lastX = x;
                this.profileState.lastY = y;
            },
            
            endProfileDrawing() {
                this.profileState.isDrawing = false;
                this.saveProfileToLocalStorage();
            },
            
            clearProfileCanvas() {
                const { canvas, ctx } = this.profileState;
                
                // Save current state for undo
                this.saveProfileState();
                
                // Clear canvas
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                this.saveProfileToLocalStorage();
            },
            
            saveProfileState() {
                const { canvas } = this.profileState;
                const imageData = canvas.toDataURL('image/png');
                this.profileState.undoStack.push(imageData);
                
                // Limit stack size
                if (this.profileState.undoStack.length > 10) {
                    this.profileState.undoStack.shift();
                }
                
                // Clear redo stack
                this.profileState.redoStack = [];
            },
            
            saveProfileToLocalStorage() {
                const { canvas } = this.profileState;
                const imageData = canvas.toDataURL('image/png');
                localStorage.setItem('playerProfile', imageData);
            },
            
            loadSavedProfile() {
                const savedProfile = localStorage.getItem('playerProfile');
                if (savedProfile && this.profileState) {
                    const img = new Image();
                    img.onload = () => {
                        this.profileState.ctx.drawImage(img, 0, 0);
                    };
                    img.src = savedProfile;
                }
            },
            
            updateToolStyles() {
                const toolButtons = document.querySelectorAll('.tool-btn[data-tool]');
                toolButtons.forEach(btn => {
                    btn.classList.toggle('bg-indigo-100', btn.dataset.tool === this.currentTool);
                });
                
                const colorButtons = document.querySelectorAll('.color-picker button');
                colorButtons.forEach(btn => {
                    btn.classList.toggle('ring-2', btn.dataset.color === this.currentColor);
                });
            },

            handleDrawStart(e) {
                console.log('Draw start', e);
                if (!this.profileState) {
                    console.error('Drawing state not initialized');
                    this.showStatus('Drawing not ready. Please refresh the page.', 'error');
                    return;
                }
                
                const { ctx, canvas } = this.drawingState;
                const rect = canvas.getBoundingClientRect();
                
                // Get coordinates
                let x, y;
                if (e.touches) {
                    const touch = e.touches[0];
                    x = ((touch.clientX - rect.left) / rect.width) * canvas.width;
                    y = ((touch.clientY - rect.top) / rect.height) * canvas.height;
                    console.log('Touch coordinates:', { x, y, raw: { x: touch.clientX, y: touch.clientY } });
                } else {
                    x = (e.offsetX / rect.width) * canvas.width;
                    y = (e.offsetY / rect.height) * canvas.height;
                    console.log('Mouse coordinates:', { x, y });
                }
                
                this.isDrawing = true;
                this.lastX = x;
                this.lastY = y;
                
                // Configure drawing style
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = this.brushSize;
                
                if (this.currentTool === 'eraser') {
                    ctx.globalCompositeOperation = 'destination-out';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                // Start path
                ctx.beginPath();
                ctx.moveTo(x, y);
                
                // Draw initial point
                ctx.arc(x, y, this.brushSize / 2, 0, Math.PI * 2);
                ctx.fill();
                
                // Save state for undo
                this.saveDrawingState();
                
                // Haptic feedback
                if (window.navigator.vibrate) {
                    window.navigator.vibrate(50);
                }
            },
            
            handleDrawMove(e) {
                if (!this.isDrawing || !this.profileState) return;
                
                const { ctx, canvas } = this.profileState;
                const rect = canvas.getBoundingClientRect();
                
                // Get coordinates
                const x = (e.offsetX / rect.width) * canvas.width;
                const y = (e.offsetY / rect.height) * canvas.height;
                
                // Draw line
                ctx.beginPath();
                ctx.moveTo(this.lastX, this.lastY);
                ctx.lineTo(x, y);
                ctx.stroke();
                
                // Update position
                this.lastX = x;
                this.lastY = y;
            },
            
            handleDrawEnd() {
                if (!this.profileState) return;
                
                this.isDrawing = false;
                this.saveDrawingState();
            },
            
            saveDrawingState() {
                if (!this.profileState) return;
                
                const { canvas } = this.profileState;
                const imageData = canvas.toDataURL('image/png');
                this.profileState.undoStack.push(imageData);
                
                // Limit stack size
                if (this.profileState.undoStack.length > 10) {
                    this.profileState.undoStack.shift();
                }
                
                // Clear redo stack
                this.profileState.redoStack = [];
            },

            resetJoinButton() {
                const joinButton = document.getElementById('joinButton');
                if (joinButton) {
                    joinButton.disabled = false;
                    joinButton.querySelector('.join-text').textContent = 'Join Game';
                    joinButton.querySelector('.loading-spinner').classList.add('hidden');
                }
            },

            async validateProfilePicture(profileData) {
                return new Promise((resolve) => {
                    const img = new Image();
                    img.onload = () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = img.width;
                        canvas.height = img.height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0);
                        
                        // Get image data
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const data = imageData.data;
                        
                        // Check if there are any non-white pixels
                        let hasDrawing = false;
                        for (let i = 0; i < data.length; i += 4) {
                            const r = data[i];
                            const g = data[i + 1];
                            const b = data[i + 2];
                            const a = data[i + 3];
                            
                            // Check if pixel is not white or transparent
                            if (a > 0 && (r !== 255 || g !== 255 || b !== 255)) {
                                hasDrawing = true;
                                break;
                            }
                        }
                        
                        resolve(hasDrawing);
                    };
                    img.src = profileData;
                });
            },

            async generateDefaultProfile(letter) {
                const canvas = document.createElement('canvas');
                canvas.width = 128;
                canvas.height = 128;
                const ctx = canvas.getContext('2d');
                
                // Generate random pastel color
                const hue = Math.random() * 360;
                const saturation = 70 + Math.random() * 10; // 70-80%
                const lightness = 75 + Math.random() * 10;  // 75-85%
                const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;
                
                // Draw background
                ctx.fillStyle = bgColor;
                ctx.beginPath();
                ctx.arc(64, 64, 64, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw letter
                ctx.fillStyle = '#FFFFFF';
                ctx.font = 'bold 64px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(letter, 64, 64);
                
                // Add subtle shadow
                ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;
                
                return canvas;
            },

            // Initialize socket connection
            initSocket() {
                console.log('Initializing socket connection...');
                // Basic socket initialization with reliable defaults
                this.socket = io({
                    path: '/socket.io/',
                    transports: ['websocket', 'polling'],  // Try WebSocket first
                    reconnection: true,
                    reconnectionAttempts: Infinity,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    timeout: 20000,
                    autoConnect: false,  // We'll connect manually
                    query: { 
                        room_id: this.roomId,
                        client_type: 'player'
                    }
                });

                // Update connection status immediately
                this.updateConnectionStatus('Connecting to server...');

                // Connect manually
                this.socket.connect();

                // Add connection event handlers
                this.socket.on('connect_error', (error) => {
                    console.error('Connection error:', error);
                    this.updateConnectionStatus('Connection error: ' + error.message, true);
                    this.showNotification('Connection error. Please check your internet connection.', 'error');
                });

                this.socket.on('connect_timeout', () => {
                    console.error('Connection timeout');
                    this.updateConnectionStatus('Connection timeout. Please try again.', true);
                    this.showNotification('Connection timeout. Please try again.', 'error');
                });
                
                // Initialize touch gesture support
                this.initTouchGestures();

                // Connection state recovery
                this.socket.on('disconnect', (reason) => {
                    console.log('Disconnected:', reason);
                    this.showNotification('Connection lost. Attempting to reconnect...', 'warning');
                    this.debugState.socketConnected = false;
                    this.debugState.lastError = {
                        time: new Date().toISOString(),
                        type: 'disconnect',
                        reason: reason
                    };
                    this.updateDebugInfo();
                    
                    // Attempt to recover state after reconnection
                    if (this.hasJoined) {
                        this.socket.once('connect', () => {
                            this.socket.emit('recover_state', {
                                room_id: this.roomId,
                                client_id: this.socket.io.opts.query.client_id
                            });
                        });
                    }
                });

                // Handle state recovery response
                this.socket.on('state_recovered', (state) => {
                    console.log('State recovered:', state);
                    this.showNotification('Game state recovered!', 'success');
                    if (state.gameArea) {
                        document.getElementById('gameArea').innerHTML = state.gameArea;
                    }
                });

                this.setupSocketListeners();
                this.socket.connect();  // Manual connection
            },

            handleGameStarted(data) {
                // Hide welcome screen and show game screen
                document.getElementById('welcomeScreen').classList.add('hidden');
                document.getElementById('gameArea').classList.remove('hidden');
                
                // Hide all game screens first
                document.getElementById('triviaScreen')?.classList.add('hidden');
                document.getElementById('chaseScreen')?.classList.add('hidden');
                document.getElementById('drawingScreen')?.classList.add('hidden');
                
                // Show appropriate game screen
                if (data.game_type === 'trivia') {
                    document.getElementById('triviaScreen').classList.remove('hidden');
                    document.getElementById('questionText').textContent = data.question.question;
                    const options = document.getElementById('answerOptions');
                    options.innerHTML = '';
                    data.question.options.forEach(option => {
                        const button = document.createElement('button');
                        button.className = 'w-full p-4 text-left bg-white border-2 border-gray-200 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500';
                        button.textContent = option;
                        button.onclick = () => this.submitAnswer(option);
                        options.appendChild(button);
                    });
                } else if (data.game_type === 'chase') {
                    document.getElementById('chaseScreen').classList.remove('hidden');
                    this.isChaser = data.is_chaser;
                    document.getElementById('chaseRole').textContent = data.is_chaser ? 'You are the Chaser!' : 'You are the Contestant!';
                    document.getElementById('chaseStatus').textContent = `Category: ${data.chase_category}`;
                    this.initChaseBoard(data.board_size);
                } else if (data.game_type === 'chinese_whispers') {
                    document.getElementById('drawingScreen').classList.remove('hidden');
                    this.isDrawer = data.is_drawer;
                    if (data.is_drawer) {
                        document.getElementById('drawingWord').textContent = `Draw: ${data.word}`;
                        document.getElementById('drawingTurn').textContent = 'Your turn to draw!';
                        this.initDrawingCanvas();
                    } else {
                        document.getElementById('drawingWord').textContent = 'Waiting for drawing...';
                        document.getElementById('drawingTurn').textContent = 'Watch the drawing and guess the word';
                    }
                }
                
                // Update scores if available
                if (data.scores) {
                    this.updateScores(data.scores);
                }
                
                // Start timer if provided
                if (data.time_limit) {
                    this.startTimer(data.time_limit);
                }
            },

            updateScores(scores) {
                let scoresList = document.getElementById('scoresList');
                if (!scoresList) {
                    const gameArea = document.getElementById('gameArea');
                    scoresList = document.createElement('div');
                    scoresList.id = 'scoresList';
                    scoresList.className = 'fixed top-4 right-4 bg-white p-4 rounded-lg shadow-lg';
                    gameArea.appendChild(scoresList);
                }
                
                scoresList.innerHTML = '<h3 class="font-bold mb-2">Scores</h3>';
                Object.entries(scores)
                    .sort(([,a], [,b]) => b - a)
                    .forEach(([playerId, score]) => {
                        const player = this.players.find(p => p.id === playerId) || { name: 'Unknown' };
                        const div = document.createElement('div');
                        div.className = 'flex justify-between items-center mb-1';
                        div.innerHTML = `
                            <span class="mr-4">${player.name}</span>
                            <span class="font-mono">${score}</span>
                        `;
                        scoresList.appendChild(div);
                    });
            },

            initDrawingCanvas() {
                const canvas = document.getElementById('drawingCanvas');
                const ctx = canvas.getContext('2d');
                
                // Set canvas size
                const container = canvas.parentElement;
                canvas.width = container.clientWidth;
                canvas.height = container.clientWidth * 0.75; // 4:3 aspect ratio
                
                // Set default styles
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                // Drawing state
                let isDrawing = false;
                let lastX = 0;
                let lastY = 0;
                
                // Touch handling
                function getTouchPos(e) {
                    const rect = canvas.getBoundingClientRect();
                    const touch = e.touches[0];
                    return {
                        x: touch.clientX - rect.left,
                        y: touch.clientY - rect.top
                    };
                }
                
                // Mouse/Touch events
                canvas.addEventListener('mousedown', startDrawing);
                canvas.addEventListener('mousemove', draw);
                canvas.addEventListener('mouseup', stopDrawing);
                canvas.addEventListener('mouseout', stopDrawing);
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    const pos = getTouchPos(e);
                    startDrawing({ offsetX: pos.x, offsetY: pos.y });
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const pos = getTouchPos(e);
                    draw({ offsetX: pos.x, offsetY: pos.y });
                });
                
                canvas.addEventListener('touchend', stopDrawing);
                canvas.addEventListener('touchcancel', stopDrawing);
                
                // Drawing functions
                function startDrawing(e) {
                    isDrawing = true;
                    [lastX, lastY] = [e.offsetX, e.offsetY];
                }
                
                const draw = (e) => {
                    if (!isDrawing) return;
                    
                    ctx.beginPath();
                    ctx.moveTo(lastX, lastY);
                    ctx.lineTo(e.offsetX, e.offsetY);
                    ctx.stroke();
                    
                    [lastX, lastY] = [e.offsetX, e.offsetY];
                    
                    // Send drawing data to server
                    this.socket.emit('drawing', {
                        room_id: this.roomId,
                        drawing: canvas.toDataURL()
                    });
                }
                
                function stopDrawing() {
                    isDrawing = false;
                }
                
                // Tool buttons
                document.querySelectorAll('.color-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        ctx.strokeStyle = btn.dataset.color;
                    });
                });
                
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        if (btn.dataset.tool === 'brush') {
                            ctx.strokeStyle = document.querySelector('.color-btn.active')?.dataset.color || '#000000';
                            ctx.globalCompositeOperation = 'source-over';
                        } else if (btn.dataset.tool === 'eraser') {
                            ctx.globalCompositeOperation = 'destination-out';
                        }
                    });
                });
            },

            displayDrawing(drawingData) {
                const canvas = document.getElementById('drawingCanvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
                img.src = drawingData;
            },

            startTimer(seconds) {
                if (this.timerInterval) {
                    clearInterval(this.timerInterval);
                }
                
                const timerElement = document.getElementById('timer');
                if (!timerElement) {
                    const gameArea = document.getElementById('gameArea');
                    const timerDiv = document.createElement('div');
                    timerDiv.id = 'timer';
                    timerDiv.className = 'fixed top-4 left-4 bg-white p-4 rounded-lg shadow-lg text-2xl font-bold';
                    gameArea.appendChild(timerDiv);
                }
                
                let timeLeft = seconds;
                const updateTimer = () => {
                    const timerElement = document.getElementById('timer');
                    if (!timerElement) return;
                    
                    timerElement.textContent = timeLeft;
                    if (timeLeft <= 5) {
                        timerElement.classList.add('text-red-500');
                        // Play tick sound if available
                        if (this.sounds?.tick) {
                            this.sounds.tick.play();
                        }
                    }
                    
                    if (timeLeft <= 0) {
                        clearInterval(this.timerInterval);
                        // Play time up sound if available
                        if (this.sounds?.timeUp) {
                            this.sounds.timeUp.play();
                        }
                        // Auto-submit current answer/drawing if needed
                        if (this.currentGame === 'trivia' && !this.hasSubmitted) {
                            this.submitAnswer(null);
                        } else if (this.currentGame === 'chinese_whispers' && this.isDrawer) {
                            this.submitDrawing();
                        }
                    }
                    timeLeft--;
                };
                
                updateTimer();
                this.timerInterval = setInterval(updateTimer, 1000);
            },

            generateClientId() {
                const timestamp = new Date().getTime();
                const random = Math.floor(Math.random() * 1000000);
                return `${timestamp}-${random}`;
            },

            detectPlatform() {
                const ua = navigator.userAgent;
                const platform = {
                    mobile: /Mobile|Android|iOS|iPhone|iPad|iPod/i.test(ua),
                    ios: /iPad|iPhone|iPod/.test(ua),
                    android: /Android/.test(ua),
                    tablet: /Tablet|iPad/i.test(ua)
                };
                return JSON.stringify(platform);
            },

            initTouchGestures() {
                // Initialize Hammer.js for touch gestures
                const gameArea = document.getElementById('gameArea');
                if (!gameArea) return;

                const hammer = new Hammer(gameArea);
                
                // Drawing gestures
                hammer.get('pan').set({ direction: Hammer.DIRECTION_ALL });
                hammer.get('pinch').set({ enable: true });
                
                // Handle drawing gestures
                hammer.on('panstart', (e) => {
                    if (this.isDrawing) {
                        this.handleDrawStart(e.center.x, e.center.y);
                    }
                });
                
                hammer.on('panmove', (e) => {
                    if (this.isDrawing) {
                        this.handleDrawMove(e.center.x, e.center.y);
                    }
                });
                
                hammer.on('panend', () => {
                    if (this.isDrawing) {
                        this.handleDrawEnd();
                    }
                });
                
                // Pinch to zoom canvas
                hammer.on('pinch', (e) => {
                    if (this.isDrawing) {
                        const canvas = document.querySelector('.drawing-canvas');
                        if (canvas) {
                            const scale = Math.max(0.5, Math.min(2, e.scale));
                            canvas.style.transform = `scale(${scale})`;
                        }
                    }
                });
                
                // Double tap for quick actions
                hammer.on('doubletap', (e) => {
                    const target = e.target;
                    if (target.classList.contains('tool-button')) {
                        // Quick tool selection
                        this.selectTool(target.dataset.tool);
                    }
                });
                
                // Initialize touch optimizations
                this.initTouchOptimizations();
            },
            
            handleDrawStart(x, y) {
                if (!this.drawingOptimizations) return;
                
                const canvas = document.querySelector('.drawing-canvas');
                if (!canvas) return;
                
                // Get relative position
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const point = {
                    x: (x - rect.left) * scaleX,
                    y: (y - rect.top) * scaleY,
                    pressure: this.drawingOptimizations.pressureSupport ? event.pressure : 1
                };
                
                this.drawingOptimizations.drawPoints = [point];
                this.drawPoint(point);
            },
            
            handleDrawMove(x, y) {
                if (!this.drawingOptimizations || !this.isDrawing) return;
                
                const canvas = document.querySelector('.drawing-canvas');
                if (!canvas) return;
                
                // Get relative position
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                
                const point = {
                    x: (x - rect.left) * scaleX,
                    y: (y - rect.top) * scaleY,
                    pressure: this.drawingOptimizations.pressureSupport ? event.pressure : 1
                };
                
                // Add point to batch
                this.drawingOptimizations.drawPoints.push(point);
                
                // Process batch if size threshold reached
                if (this.drawingOptimizations.drawPoints.length >= this.drawingOptimizations.batchSize) {
                    this.processBatch();
                } else {
                    // Schedule batch processing
                    if (this.drawingOptimizations.drawTimer) {
                        clearTimeout(this.drawingOptimizations.drawTimer);
                    }
                    this.drawingOptimizations.drawTimer = setTimeout(() => {
                        this.processBatch();
                    }, this.drawingOptimizations.batchTimeout);
                }
            },
            
            processBatch() {
                if (!this.drawingOptimizations || !this.drawingOptimizations.drawPoints.length) return;
                
                const points = this.drawingOptimizations.drawPoints;
                const ctx = this.drawingOptimizations.ctx;
                
                // Optimize path drawing
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                
                // Use quadratic curves for smoother lines
                for (let i = 1; i < points.length - 1; i++) {
                    const xc = (points[i].x + points[i + 1].x) / 2;
                    const yc = (points[i].y + points[i + 1].y) / 2;
                    ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
                }
                
                // Draw the path
                ctx.stroke();
                
                // Update main canvas
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    const mainCtx = canvas.getContext('2d');
                    mainCtx.drawImage(this.drawingOptimizations.offscreenCanvas, 0, 0);
                }
                
                // Clear batch
                this.drawingOptimizations.drawPoints = [];
                
                // Monitor performance
                this.drawingOptimizations.frameCount++;
                const now = performance.now();
                if (now - this.drawingOptimizations.lastFrameTime >= 1000) {
                    this.drawingOptimizations.fps = this.drawingOptimizations.frameCount;
                    this.drawingOptimizations.frameCount = 0;
                    this.drawingOptimizations.lastFrameTime = now;
                    
                    // Adjust batch size based on FPS
                    if (this.drawingOptimizations.fps < 30) {
                        this.drawingOptimizations.batchSize = Math.min(10, this.drawingOptimizations.batchSize + 1);
                    } else if (this.drawingOptimizations.fps > 55) {
                        this.drawingOptimizations.batchSize = Math.max(3, this.drawingOptimizations.batchSize - 1);
                    }
                }
            },
            
            drawPoint(point) {
                if (!this.drawingOptimizations || !this.drawingOptimizations.ctx) return;
                
                const ctx = this.drawingOptimizations.ctx;
                ctx.beginPath();
                ctx.arc(point.x, point.y, this.currentBrushSize * point.pressure, 0, Math.PI * 2);
                ctx.fill();
            },
            
            initTouchOptimizations() {
                // Drawing optimizations
                this.drawingOptimizations = {
                    // Batch drawing updates
                    batchSize: 5,
                    batchTimeout: 50,
                    drawPoints: [],
                    drawTimer: null,
                    
                    // Canvas optimization
                    offscreenCanvas: null,
                    ctx: null,
                    
                    // Touch pressure support
                    pressureSupport: 'pressure' in TouchEvent.prototype,
                    
                    // Performance monitoring
                    lastFrameTime: 0,
                    frameCount: 0,
                    fps: 0
                };
                
                // Initialize offscreen canvas
                const canvas = document.querySelector('.drawing-canvas');
                if (canvas) {
                    this.drawingOptimizations.offscreenCanvas = new OffscreenCanvas(
                        canvas.width,
                        canvas.height
                    );
                    this.drawingOptimizations.ctx = this.drawingOptimizations.offscreenCanvas.getContext('2d', {
                        alpha: false,
                        desynchronized: true
                    });
                }
                
                // Prevent unwanted touch behaviors
                document.addEventListener('touchmove', (e) => {
                    if (e.target.classList.contains('drawing-canvas')) {
                        e.preventDefault();
                        
                        // Handle drawing with pressure sensitivity
                        if (this.isDrawing && this.drawingOptimizations.pressureSupport) {
                            const touch = e.touches[0];
                            this.updateBrushSize(touch.pressure * 20);  // Scale pressure to brush size
                        }
                    }
                }, { passive: false });
                
                // Optimize scrolling
                const scrollElements = document.querySelectorAll('.smooth-scroll');
                scrollElements.forEach(el => {
                    el.addEventListener('touchstart', () => {
                        el.style.overflow = 'auto';
                    });
                    
                    el.addEventListener('touchend', () => {
                        setTimeout(() => {
                            el.style.overflow = 'hidden';
                        }, 50);
                    });
                });
                
                // Add touch feedback
                const buttons = document.querySelectorAll('.game-button');
                buttons.forEach(btn => {
                    btn.addEventListener('touchstart', () => {
                        btn.style.transform = 'scale(0.95)';
                    });
                    
                    btn.addEventListener('touchend', () => {
                        btn.style.transform = 'scale(1)';
                    });
                });
            },

            // Set up socket event listeners
            setupSocketListeners() {
                this.socket.on('connect', () => {
                    console.log('Socket connected');
                    this.updateConnectionStatus('Connected to server');
                    this.debugState.socketConnected = true;
                    this.updateDebugInfo();
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Socket connection error:', error);
                    this.updateConnectionStatus('Connection error: ' + error.message, true);
                    this.debugState.socketConnected = false;
                    this.debugState.lastError = {
                        time: new Date().toISOString(),
                        type: 'connect_error',
                        message: error.message
                    };
                    this.updateDebugInfo();
                });

                this.socket.on('join_confirmed', (data) => {
                    console.log('Join confirmed:', data);
                    this.hasJoined = true;
                    this.showNotification('Successfully joined the game!');
                    this.transitionToGame();
                });

                this.socket.on('join_error', (error) => {
                    console.error('Join error:', error);
                    this.showNotification(error.message || 'Failed to join game', 'error');
                    
                    // Re-enable join button
                    const joinButton = document.querySelector('button[onclick="window.gameState.joinGame()"]');
                    if (joinButton) {
                        joinButton.disabled = false;
                        joinButton.querySelector('.join-text').textContent = 'Join Game';
                        joinButton.querySelector('.loading-spinner').classList.add('hidden');
                    }
                    this.showNotification(error.message || 'Failed to join game', 'error');
                    this.resetJoinButton();
                });
            },

            // Join game function
            async joinGame() {
                console.log('Join game called');
                const playerName = document.getElementById('playerName').value.trim();
                console.log('Attempting to join with name:', playerName);

                if (!playerName) {
                    this.showNotification('Please enter your name', 'error');
                    return;
                }

                // Validate name length
                if (playerName.length < 2 || playerName.length > 20) {
                    this.showNotification('Name must be between 2 and 20 characters', 'error');
                    return;
                }

                this.debugState.joinAttempts++;
                this.updateDebugInfo();

                const joinButton = document.querySelector('button[onclick="window.gameState.joinGame()"]');
                if (joinButton) {
                    joinButton.disabled = true;
                    joinButton.querySelector('.join-text').textContent = 'Joining...';
                    joinButton.querySelector('.loading-spinner').classList.remove('hidden');
                }

                try {
                    // Ensure socket is connected
                    if (!this.socket.connected) {
                        console.log('Socket not connected, attempting to connect...');
                        this.showNotification('Connecting to server...', 'info');
                        try {
                            await new Promise((resolve, reject) => {
                                this.socket.connect();
                                this.socket.once('connect', resolve);
                                this.socket.once('connect_error', (error) => reject(error));
                                // Timeout after 5 seconds
                                setTimeout(() => reject(new Error('Connection timeout')), 5000);
                            });
                        } catch (error) {
                            console.error('Connection failed:', error);
                            this.showNotification('Failed to connect to server. Please check your internet connection and try again.', 'error');
                            throw error;
                        }
                    }

                    // Get profile picture data
                    let profileData;
                    if (this.profileState && this.profileState.canvas) {
                        profileData = this.profileState.canvas.toDataURL('image/png', 0.8);
                        
                        // Validate profile picture (ensure it's not empty)
                        const hasDrawing = await this.validateProfilePicture(profileData);
                        if (!hasDrawing) {
                            console.log('No drawing found, generating default profile');
                            // Generate default profile with first letter of name
                            const defaultProfile = await this.generateDefaultProfile(playerName[0].toUpperCase());
                            this.profileState.ctx.drawImage(defaultProfile, 0, 0);
                            profileData = this.profileState.canvas.toDataURL('image/png', 0.8);
                        }

                        // Save final profile
                        this.saveProfileToLocalStorage();
                    } else {
                        console.warn('Profile state or canvas not initialized');
                        // Generate a default profile
                        const defaultProfile = await this.generateDefaultProfile(playerName[0].toUpperCase());
                        profileData = defaultProfile.toDataURL('image/png', 0.8);
                    }

                    console.log('Emitting join_room event');
                    // Join room with profile
                    console.log('Attempting to join room:', this.roomId);
                    this.showNotification('Joining game...', 'info');
                    
                    this.socket.emit('join_room', {
                        room_id: this.roomId,
                        player_name: playerName,
                        profile_picture: profileData,
                        is_host: false,
                        client_id: this.socket.id
                    });

                    // Set up response timeout
                    const joinTimeout = setTimeout(() => {
                        console.error('Join room timeout');
                        this.showNotification('Connection timeout. Please try again.', 'error');
                        this.resetJoinButton(joinButton);
                    }, 10000);

                    // Wait for response
                    await new Promise((resolve, reject) => {
                        this.socket.once('join_confirmed', () => {
                            clearTimeout(joinTimeout);
                            resolve();
                        });
                        this.socket.once('join_error', (error) => {
                            clearTimeout(joinTimeout);
                            reject(new Error(error.message || 'Failed to join game'));
                        });
                    });

                } catch (error) {
                    console.error('Error joining game:', error);
                    this.showNotification(error.message || 'Failed to join game. Please try again.', 'error');
                    this.resetJoinButton();
                    
                    // Update debug info
                    this.debugState.lastError = {
                        time: new Date().toISOString(),
                        type: 'join_error',
                        message: error.message
                    };
                    this.updateDebugInfo();
                    
                    // Retry connection if it was a connection error
                    if (error.message.includes('Connection timeout') || error.message.includes('connect')) {
                        this.socket.disconnect();
                        setTimeout(() => {
                            this.socket.connect();
                        }, 1000);
                    }
                }
            },

            // UI helper functions
            updateConnectionStatus(status, isError = false) {
                const statusEl = document.getElementById('connectionStatus');
                if (statusEl) {
                    statusEl.textContent = status;
                    statusEl.className = `text-sm ${isError ? 'text-red-600' : 'text-gray-600'} mb-4`;
                }
            },

            showNotification(message, type = 'info') {
                const toast = document.getElementById('connectionToast');
                const toastText = document.getElementById('connectionToastText');
                
                if (toast && toastText) {
                    toastText.textContent = message;
                    toast.className = `fixed bottom-4 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-full text-sm z-50 ${
                        type === 'error' ? 'bg-red-600 text-white' : 'bg-black/80 text-white'
                    }`;
                    toast.classList.remove('hidden');
                    
                    setTimeout(() => {
                        toast.classList.add('hidden');
                    }, 3000);
                }
            },

            resetJoinButton() {
                const joinButton = document.getElementById('joinButton');
                if (joinButton) {
                    joinButton.disabled = false;
                    joinButton.querySelector('.join-text').textContent = 'Join Game';
                    joinButton.querySelector('.loading-spinner').classList.add('hidden');
                }
            },

            transitionToGame() {
                const nameInput = document.getElementById('nameInput');
                const gameArea = document.getElementById('gameArea');
                
                if (nameInput && gameArea) {
                    nameInput.style.opacity = '0';
                    nameInput.style.transition = 'opacity 0.5s ease-out';
                    
                    setTimeout(() => {
                        nameInput.classList.add('hidden');
                        gameArea.classList.remove('hidden');
                        gameArea.style.opacity = '0';
                        requestAnimationFrame(() => {
                            gameArea.style.transition = 'opacity 0.5s ease-in';
                            gameArea.style.opacity = '1';
                        });
                    }, 500);
                }
            },

            // Debug functions
            toggleDebug() {
                const overlay = document.getElementById('debugOverlay');
                this.debugVisible = !this.debugVisible;
                if (overlay) {
                    overlay.classList.toggle('hidden', !this.debugVisible);
                    if (this.debugVisible) {
                        this.updateDebugInfo();
                    }
                }
            },

            updateDebugInfo() {
                const debugInfo = document.getElementById('debugInfo');
                if (debugInfo) {
                    debugInfo.textContent = JSON.stringify({
                        roomId: this.roomId,
                        socketConnected: this.debugState.socketConnected,
                        hasJoined: this.hasJoined,
                        joinAttempts: this.debugState.joinAttempts,
                        lastError: this.debugState.lastError,
                        events: this.debugState.events
                    }, null, 2);
                }
            },

            addKeyboardListeners() {
                document.addEventListener('keydown', (e) => {
                    if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                        this.toggleDebug();
                    }
                });

                // Add enter key listener for the name input
                document.getElementById('playerName').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        this.joinGame();
                    }
                });
            }
        };

        // Attach gameState to window
        window.gameState = gameState;

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, initializing game...');
            try {
                window.gameState.init();
                console.log('Game initialized successfully');
            } catch (error) {
                console.error('Error initializing game:', error);
            }
        });
    </script>
</body>
</html>