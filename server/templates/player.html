<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"/>
  <meta name="mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <title>Play Game - Party Games Hub</title>

  <!-- Tailwind CSS -->
  <link
    href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css"
    rel="stylesheet"
  />
  <!-- FontAwesome -->
  <link
    href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
    rel="stylesheet"
  />
  <!-- Socket.io -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js"></script>
  <!-- Hammer.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>

  <style>
    /* Mobile optimizations */
    * {
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }

    /* Prevent text selection */
    .no-select {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Mobile-friendly canvas */
    .drawing-canvas {
      touch-action: none;
      width: 100%;
      max-width: 600px;
      height: auto;
      aspect-ratio: 4/3;
    }

    /* Mobile-friendly buttons */
    .game-button {
      min-height: 44px; /* iOS minimum tap target size */
      padding: 12px 20px;
      margin: 8px;
      border-radius: 8px;
      font-size: 16px;
      transition: transform 0.1s;
    }

    .game-button:active {
      transform: scale(0.95);
    }

    /* Responsive game area */
    @media (max-width: 640px) {
      .game-container {
        padding: 12px;
      }

      .drawing-tools {
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(10px);
        padding: 8px;
        z-index: 100;
        display: flex;
        justify-content: space-around;
        box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
      }

      .tool-button {
        width: 40px;
        height: 40px;
        padding: 8px;
        border-radius: 50%;
      }
    }

    /* Smooth scrolling */
    .smooth-scroll {
      -webkit-overflow-scrolling: touch;
      scroll-behavior: smooth;
    }

    /* Loading spinner optimization */
    @keyframes optimized-spin {
      to {
        transform: rotate(360deg);
      }
    }
    .optimized-spinner {
      animation: optimized-spin 1s linear infinite;
      will-change: transform;
    }
  </style>
</head>

<body>
  <!-- Debug Overlay -->
  <div
    id="debugOverlay"
    class="fixed top-0 right-0 bg-black/80 text-white p-4 m-4 rounded-lg text-sm font-mono max-w-xs overflow-auto max-h-96 hidden z-50"
  >
    <div class="flex justify-between items-center mb-2">
      <h3 class="font-bold">Debug Info</h3>
      <button
        onclick="window.gameState.toggleDebug()"
        class="text-gray-400 hover:text-white px-2"
      >
        [X]
      </button>
    </div>
    <div class="text-xs mb-2">Press Ctrl+Shift+D to toggle</div>
    <pre
      id="debugInfo"
      class="whitespace-pre-wrap text-xs leading-tight"
    ></pre>
  </div>

  <!-- Connection Status Toast -->
  <div
    id="connectionToast"
    class="fixed bottom-4 left-1/2 transform -translate-x-1/2 bg-black/80 text-white px-4 py-2 rounded-full text-sm hidden"
  >
    <span id="connectionToastText"></span>
  </div>

  <div class="container mx-auto">
    <div class="game-container">
      <!-- Player Name Input -->
      <div
        id="nameInput"
        class="fixed inset-0 flex items-center justify-center bg-gradient-to-br from-indigo-500/90 to-purple-600/90 backdrop-blur-sm"
      >
        <div
          class="bg-white p-8 rounded-2xl shadow-2xl max-w-md w-11/12 md:w-96 transform transition-all"
        >
          <h2 class="text-3xl font-bold text-indigo-600 mb-6">Join Game</h2>
          <div
            id="connectionStatus"
            class="text-sm font-medium mb-4 transition-all"
          >
            <div class="flex items-center space-x-2 text-indigo-600">
              <svg
                class="animate-spin h-4 w-4"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
              <span>Connecting to server...</span>
            </div>
          </div>
          <div
            id="roomInfo"
            class="text-sm bg-gray-100 p-3 rounded-lg mb-4 border border-gray-200"
          >
            <div class="flex justify-between items-center">
              <span class="font-medium">Room Code:</span>
              <span
                class="font-mono bg-white px-2 py-1 rounded border border-gray-200"
              >
                {{ room_id }}
              </span>
            </div>
            <div
              class="mt-2 text-xs text-gray-500"
              id="roomStatus"
            >
              Checking room status...
            </div>
          </div>

          <!-- Status Messages -->
          <div
            id="statusMessages"
            class="fixed bottom-4 left-1/2 transform -translate-x-1/2 w-11/12 max-w-md space-y-2 z-50"
          ></div>
          <div class="space-y-6">
            <div>
              <label
                for="playerName"
                class="block text-sm font-medium text-gray-700 mb-1"
                >Your Name</label
              >
              <input
                type="text"
                id="playerName"
                class="w-full p-3 border-2 border-gray-300 rounded-xl focus:outline-none focus:ring-2 focus:ring-indigo-400 focus:border-indigo-400 transition-all"
                placeholder="Enter your name"
                maxlength="20"
              />
              <p class="text-xs text-gray-500 mt-1">
                Maximum 20 characters
              </p>
            </div>

            <div class="profile-picture-section mb-20">
              <label
                class="block text-sm font-medium text-gray-700 mb-3"
                >Profile Picture</label
              >
              <div
                class="profile-canvas-container relative bg-gray-50 rounded-xl p-4 border-2 border-dashed border-gray-300 hover:border-indigo-400 transition-all"
              >
                <canvas
                  id="profileCanvas"
                  class="w-32 h-32 mx-auto bg-white rounded-full shadow-inner cursor-crosshair touch-none"
                  width="128"
                  height="128"
                ></canvas>

                <div
                  class="drawing-tools flex flex-col items-center mt-4 space-y-4 bg-white/95 p-4 rounded-lg shadow-lg"
                >
                  <!-- Color picker -->
                  <div class="color-picker flex space-x-2">
                    <button
                      class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      data-color="#000000"
                      style="background-color: #000000"
                    ></button>
                    <button
                      class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      data-color="#FF0000"
                      style="background-color: #FF0000"
                    ></button>
                    <button
                      class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      data-color="#00FF00"
                      style="background-color: #00FF00"
                    ></button>
                    <button
                      class="w-10 h-10 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      data-color="#0000FF"
                      style="background-color: #0000FF"
                    ></button>
                  </div>

                  <!-- Tool buttons -->
                  <div class="tool-buttons flex space-x-2">
                    <button
                      class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      data-tool="brush"
                      title="Brush"
                    >
                      <i class="fas fa-paint-brush text-gray-600 text-lg"></i>
                    </button>
                    <button
                      class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      data-tool="eraser"
                      title="Eraser"
                    >
                      <i class="fas fa-eraser text-gray-600 text-lg"></i>
                    </button>
                    <button
                      class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95"
                      onclick="window.gameState.clearProfileCanvas()"
                      title="Clear"
                    >
                      <i class="fas fa-trash-alt text-gray-600 text-lg"></i>
                    </button>
                  </div>

                  <!-- Size slider -->
                  <div class="size-slider w-full px-2">
                    <input
                      type="range"
                      id="profileBrushSize"
                      min="1"
                      max="20"
                      value="4"
                      class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                    />
                  </div>
                </div>

                <div
                  class="text-xs text-gray-500 text-center mt-2"
                >
                  Draw your profile picture or tap to start
                </div>
              </div>
            </div>

            <div class="fixed bottom-0 left-0 right-0 p-4 bg-white/95 backdrop-blur-sm shadow-lg border-t border-gray-200">
              <button
                id="joinButton"
                type="button"
                class="w-full bg-indigo-600 text-white p-4 rounded-xl hover:bg-indigo-700 active:bg-indigo-800 transition-all transform hover:scale-[1.02] flex items-center justify-center space-x-2 shadow-lg"
                onclick="window.gameState.joinGame()"
              >
                <span class="join-text font-semibold"
                  >Join Game</span
                >
                <span class="loading-spinner hidden">
                  <svg
                    class="animate-spin h-5 w-5 text-white"
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                  >
                    <circle
                      class="opacity-25"
                      cx="12"
                      cy="12"
                      r="10"
                      stroke="currentColor"
                      stroke-width="4"
                    ></circle>
                    <path
                      class="opacity-75"
                      fill="currentColor"
                      d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                    ></path>
                  </svg>
                </span>
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Game Area -->
      <div id="gameArea" class="hidden">
        <!-- Welcome Screen -->
        <div id="welcomeScreen" class="text-center py-8">
          <h2 class="text-3xl font-bold text-indigo-600 mb-4">
            Welcome to Party Games!
          </h2>
          <p class="text-gray-600 mb-8">
            Waiting for the host to start a game...
          </p>
          <div class="flex flex-col items-center space-y-4">
            <div class="bg-gray-100 p-4 rounded-lg">
              <h3 class="font-semibold text-gray-700 mb-2">
                Players in Room
              </h3>
              <div id="playerList" class="space-y-2"></div>
            </div>
          </div>
        </div>

        <!-- TRIVIA SCREEN -->
        <div id="triviaScreen" class="hidden">
          <div class="max-w-2xl mx-auto">
            <div class="bg-white rounded-xl shadow-lg p-6">
              <!-- Timer -->
              <div class="mb-6">
                <div class="flex justify-between items-center mb-2">
                  <span class="text-sm font-medium text-gray-500">Time Remaining</span>
                  <span id="timer" class="text-xl font-bold text-indigo-600"></span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                  <div id="timerBar" class="bg-indigo-600 h-2 rounded-full transition-all duration-1000" style="width: 100%"></div>
                </div>
              </div>
              
              <!-- Question -->
              <div id="questionText" class="text-xl font-semibold mb-6 text-gray-800"></div>
              
              <!-- Answer Options -->
              <div id="answerOptions" class="grid grid-cols-1 gap-4">
                <!-- Answer buttons will be added here -->
              </div>
              
              <!-- Feedback -->
              <div id="triviaFeedback" class="mt-6 text-center hidden">
                <div class="correct-feedback text-green-500 hidden transform transition-all duration-300 scale-100">
                  <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                  </svg>
                  <p class="text-xl font-bold">Correct!</p>
                </div>
                <div class="wrong-feedback text-red-500 hidden transform transition-all duration-300 scale-100">
                  <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                  </svg>
                  <p class="text-xl font-bold">Wrong!</p>
                  <p class="text-gray-500 mt-2">The correct answer will be revealed soon...</p>
                </div>
              </div>
              
              <!-- Answer Status -->
              <div class="mt-6 text-center text-sm text-gray-500" id="answerStatus">
                Waiting for other players...
                <span id="answeredCount" class="font-medium">0/0</span>
              </div>
            </div>
          </div>
        </div>

    <!-- Chase Game Screen -->
<div id="chaseScreen" class="hidden">
    <div class="max-w-2xl mx-auto">
      <div class="bg-white rounded-xl shadow-lg p-6">
        <!-- Info at top: role + category -->
        <div id="chaseInfo" class="text-center mb-4">
          <div id="chaseRole" class="text-2xl font-bold mb-2 text-indigo-600"></div>
          <div id="chaseStatus" class="text-gray-600"></div>
        </div>

        <!-- Game Board -->
        <div id="chaseBoard" class="grid grid-cols-7 gap-2 mb-6 bg-gray-100 p-4 rounded-xl">
          <!-- Board positions will be dynamically added -->
        </div>

        <!-- Question Section -->
        <div id="chaseQuestion" class="bg-gray-50 rounded-xl p-6 mb-6">
          <p class="text-lg font-medium mb-4"></p>
          <div id="chaseAnswers" class="grid grid-cols-1 gap-3">
            <!-- Answer buttons will be dynamically added -->
          </div>
        </div>

        <!-- Timer -->
        <div id="chaseTimer" class="text-center text-2xl font-bold text-indigo-600"></div>

        <!-- Feedback -->
        <div id="chaseFeedback" class="mt-4 text-center hidden">
          <div class="correct-feedback text-green-500 hidden">
            <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <p class="text-xl font-bold">Correct!</p>
          </div>
          <div class="wrong-feedback text-red-500 hidden">
            <svg class="w-16 h-16 mx-auto mb-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <p class="text-xl font-bold">Wrong!</p>
          </div>
        </div>
        <!-- Board (7 columns default) -->
        <div id="chaseBoard" class="grid grid-cols-7 gap-2 mb-6">
          <!-- Dynamically created cells go here -->
        </div>
  
        <!-- The question text (hidden until question arrives) -->
        <div id="chaseQuestion" class="text-xl font-semibold mb-4 hidden"></div>
  
        <!-- The multiple-choice answers (hidden until question arrives) -->
        <div id="chaseOptions" class="grid grid-cols-1 gap-4 hidden">
          <!-- Buttons inserted in JS -->
        </div>
  
        <!-- Timer display for chase -->
        <div id="chaseTimer" class="mt-4 text-center text-2xl font-bold"></div>
  
        <!-- Feedback for each question (correct/wrong) -->
        <div id="chaseFeedback" class="mt-4 text-center hidden">
          <div class="correct-feedback text-green-500 hidden">
            <svg class="w-16 h-16 mx-auto mb-2"
                 fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <p class="text-xl font-bold">Correct!</p>
          </div>
          <div class="wrong-feedback text-red-500 hidden">
            <svg class="w-16 h-16 mx-auto mb-2"
                 fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M10 14l2-2m0 0l2-2m-2 2l-2-2
                       m2 2l2 2
                       m7-2a9 9 0 11-18 0 9 9 0 0118 0z"/>
            </svg>
            <p class="text-xl font-bold">Wrong!</p>
          </div>
        </div>
  
        <!-- Big feedback if chase ends: caught or escaped -->
        <div id="chaseFeedback2" class="mt-4 text-center hidden">
          <div class="catch-feedback text-red-500 hidden">
            <svg class="w-16 h-16 mx-auto mb-2"
                 fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M13 10V3L4 14h7v7l9-11h-7z"/>
            </svg>
            <p class="text-xl font-bold">Caught!</p>
          </div>
          <div class="escape-feedback text-green-500 hidden">
            <svg class="w-16 h-16 mx-auto mb-2"
                 fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                    d="M5 13l4 4L19 7"/>
            </svg>
            <p class="text-xl font-bold">Escaped!</p>
          </div>
        </div>
      </div>
    </div>
  </div>
  <!-- CHASE SCREEN: END NEW SNIPPET -->
  

        <!-- DRAWING (CHINESE WHISPERS) SCREEN -->
        <div id="drawingScreen" class="hidden">
          <div class="max-w-2xl mx-auto">
            <div class="bg-white rounded-xl shadow-lg p-6">
              <div id="drawingPrompt" class="text-center mb-4">
                <div id="drawingWord" class="text-2xl font-bold text-indigo-600 mb-2"></div>
                <div id="drawingTurn" class="text-gray-600"></div>
                <div id="drawingTimer" class="text-xl font-bold mt-2 text-indigo-600"></div>
              </div>
              
              <div class="drawing-area relative bg-white rounded-lg overflow-hidden mb-6">
                <canvas
                  id="drawingCanvas"
                  class="drawing-canvas mx-auto border-2 border-gray-200 rounded-lg touch-none shadow-inner"
              ></canvas>
                
                <!-- Drawing Tools -->
                <div class="drawing-tools fixed bottom-0 left-0 right-0 bg-white/95 backdrop-blur-sm p-4 shadow-lg border-t border-gray-200">
                  <div class="max-w-2xl mx-auto flex flex-wrap items-center justify-between gap-4">
                    <!-- Color Picker -->
                    <div class="flex space-x-2">
                      <button class="w-8 h-8 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" style="background-color: #000000" data-color="#000000"></button>
                      <button class="w-8 h-8 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" style="background-color: #FF0000" data-color="#FF0000"></button>
                      <button class="w-8 h-8 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" style="background-color: #00FF00" data-color="#00FF00"></button>
                      <button class="w-8 h-8 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" style="background-color: #0000FF" data-color="#0000FF"></button>
                      <button class="w-8 h-8 rounded-full border-2 border-gray-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" style="background-color: #FFFF00" data-color="#FFFF00"></button>
                    </div>
                    
                    <!-- Tools -->
                    <div class="flex space-x-2">
                      <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" data-tool="brush">
                        <i class="fas fa-paint-brush text-gray-600"></i>
                      </button>
                      <button class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" data-tool="eraser">
                        <i class="fas fa-eraser text-gray-600"></i>
                      </button>
                      <button class="w-10 h-10 rounded-lg bg-white border-2 border-gray-300 flex items-center justify-center focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-all active:scale-95" onclick="window.gameState.clearCanvas()">
                        <i class="fas fa-trash-alt text-gray-600"></i>
                      </button>
                    </div>
                    
                    <!-- Size Slider -->
                    <div class="w-full sm:w-auto flex-1 max-w-xs">
                      <input type="range" id="brushSize" min="1" max="20" value="4" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer">
                    </div>
                  </div>
                </div>
              >
                <div class="col-span-3 grid grid-cols-3 gap-2">
                  <!-- Color buttons -->
                  <button
                    class="color-btn w-10 h-10 rounded-full border-2 border-gray-300"
                    data-color="#000000"
                    style="background-color: #000000"
                  ></button>
                  <button
                    class="color-btn w-10 h-10 rounded-full border-2 border-gray-300"
                    data-color="#FF0000"
                    style="background-color: #FF0000"
                  ></button>
                  <button
                    class="color-btn w-10 h-10 rounded-full border-2 border-gray-300"
                    data-color="#00FF00"
                    style="background-color: #00FF00"
                  ></button>
                  <button
                    class="color-btn w-10 h-10 rounded-full border-2 border-gray-300"
                    data-color="#0000FF"
                    style="background-color: #0000FF"
                  ></button>
                  <button
                    class="color-btn w-10 h-10 rounded-full border-2 border-gray-300"
                    data-color="#FFFF00"
                    style="background-color: #FFFF00"
                  ></button>
                  <button
                    class="color-btn w-10 h-10 rounded-full border-2 border-gray-300"
                    data-color="#FF00FF"
                    style="background-color: #FF00FF"
                  ></button>
                </div>
                <div class="tool-buttons grid grid-cols-1 gap-2">
                  <button
                    class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300"
                    data-tool="brush"
                  >
                    <i class="fas fa-paint-brush"></i>
                  </button>
                  <button
                    class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300"
                    data-tool="eraser"
                  >
                    <i class="fas fa-eraser"></i>
                  </button>
                  <button
                    class="tool-btn w-10 h-10 rounded-lg bg-white border-2 border-gray-300"
                    onclick="clearCanvas()"
                  >
                    <i class="fas fa-trash"></i>
                  </button>
                </div>
              </div>
              <div class="flex items-center justify-between">
                <div class="brush-size flex items-center space-x-2">
                  <input
                    type="range"
                    id="brushSize"
                    min="1"
                    max="20"
                    value="4"
                    class="w-32"
                  />
                  <span id="brushSizeValue" class="text-sm">4px</span>
                </div>
                <div
                  id="drawingTimer"
                  class="text-2xl font-bold"
                ></div>
              </div>
            </div>
          </div>
        </div>

        <!-- Generic Game Feedback Overlay -->
        <div
          id="gameFeedback"
          class="fixed inset-0 bg-black/80 hidden items-center justify-center"
        >
          <div
            class="bg-white rounded-xl p-8 max-w-md w-11/12 text-center"
          >
            <div id="feedbackIcon" class="mb-4">
              <!-- Icon will be inserted here dynamically -->
            </div>
            <h3
              id="feedbackTitle"
              class="text-2xl font-bold mb-2"
            ></h3>
            <p id="feedbackMessage" class="text-gray-600 mb-4"></p>
            <div id="feedbackStats" class="grid grid-cols-2 gap-4 mb-6">
              <!-- Stats will be inserted here dynamically -->
            </div>
            <button
              id="feedbackButton"
              class="bg-indigo-600 text-white px-6 py-3 rounded-lg w-full"
            >
              Continue
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Main Script -->
  <script>
    // Initialize game state globally
    window.gameState = {
      socket: null,
      roomId: "{{ room_id }}",
      hasJoined: false,
      profileCanvas: null,
      profileCtx: null,
      profileIsDrawing: false,
      profileLastX: 0,
      profileLastY: 0,
      profileTool: 'brush',
      debugVisible: false,
      currentGame: null,
      isDrawer: false,
      isChaser: false,
      debugState: {
        socketConnected: false,
        lastError: null,
        joinAttempts: 0,
        events: [],
      },
      profileState: null, // Will hold drawing context/state for profile

      init() {
        console.log("Initializing game with room ID:", this.roomId);

        // 1) Initialize Profile Canvas
        this.initProfileCanvas();

        // 2) Initialize Socket
        this.initSocket();

        // 3) Keyboard Listeners
        this.addKeyboardListeners();

        // 4) Update Debug
        this.updateDebugInfo();

        // 5) Set default tool settings
        this.setProfileColor("#000000");
        this.setProfileTool("brush");
        this.setProfileBrushSize(4);

        // 6) Load Saved Profile
        this.loadSavedProfile();
      },

      /****************************************
       *             SOCKET SETUP
       ****************************************/
      // Initialize profile canvas
      initProfileCanvas() {
        this.profileCanvas = document.getElementById("profileCanvas");
        this.profileCtx = this.profileCanvas.getContext("2d");
        
        // Set initial drawing style
        this.profileCtx.strokeStyle = "#000000";
        this.profileCtx.lineWidth = 4;
        this.profileCtx.lineCap = "round";
        this.profileCtx.lineJoin = "round";

        // Drawing function
        const draw = (e) => {
          if (!this.profileIsDrawing) return;
          e.preventDefault();

          const rect = this.profileCanvas.getBoundingClientRect();
          const x = ((e.clientX || e.touches[0].clientX) - rect.left) * (this.profileCanvas.width / rect.width);
          const y = ((e.clientY || e.touches[0].clientY) - rect.top) * (this.profileCanvas.height / rect.height);

          this.profileCtx.beginPath();
          this.profileCtx.moveTo(this.profileLastX, this.profileLastY);
          this.profileCtx.lineTo(x, y);

          if (this.profileTool === 'eraser') {
            this.profileCtx.save();
            this.profileCtx.strokeStyle = '#FFFFFF';
            this.profileCtx.lineWidth = this.profileCtx.lineWidth * 2;
            this.profileCtx.stroke();
            this.profileCtx.restore();
          } else {
            this.profileCtx.stroke();
          }

          [this.profileLastX, this.profileLastY] = [x, y];
        };

        // Mouse events
        this.profileCanvas.addEventListener("mousedown", (e) => {
          this.profileIsDrawing = true;
          const rect = this.profileCanvas.getBoundingClientRect();
          [this.profileLastX, this.profileLastY] = [
            (e.clientX - rect.left) * (this.profileCanvas.width / rect.width),
            (e.clientY - rect.top) * (this.profileCanvas.height / rect.height)
          ];
        });
        this.profileCanvas.addEventListener("mousemove", draw);
        this.profileCanvas.addEventListener("mouseup", () => this.profileIsDrawing = false);
        this.profileCanvas.addEventListener("mouseout", () => this.profileIsDrawing = false);

        // Touch events
        this.profileCanvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          this.profileIsDrawing = true;
          const rect = this.profileCanvas.getBoundingClientRect();
          [this.profileLastX, this.profileLastY] = [
            (e.touches[0].clientX - rect.left) * (this.profileCanvas.width / rect.width),
            (e.touches[0].clientY - rect.top) * (this.profileCanvas.height / rect.height)
          ];
        });
        this.profileCanvas.addEventListener("touchmove", draw);
        this.profileCanvas.addEventListener("touchend", () => this.profileIsDrawing = false);

        // Color picker
        const colorButtons = document.querySelectorAll("[data-color]");
        colorButtons.forEach((button) => {
          button.addEventListener("click", () => {
            this.profileCtx.strokeStyle = button.dataset.color;
            this.profileTool = 'brush';
            colorButtons.forEach((btn) =>
              btn.classList.remove("ring-2", "ring-offset-2")
            );
            button.classList.add("ring-2", "ring-offset-2");
            
            // Update tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => 
              btn.classList.remove('bg-gray-100'));
            document.querySelector('[data-tool="brush"]').classList.add('bg-gray-100');
          });
        });

        // Tool buttons
        const toolButtons = document.querySelectorAll(".tool-btn");
        toolButtons.forEach((button) => {
          button.addEventListener("click", () => {
            this.profileTool = button.dataset.tool;
            toolButtons.forEach((btn) =>
              btn.classList.remove("bg-gray-100")
            );
            button.classList.add("bg-gray-100");
          });
        });

        // Brush size slider
        const sizeSlider = document.getElementById("profileBrushSize");
        sizeSlider.addEventListener("input", () => {
          this.profileCtx.lineWidth = sizeSlider.value;
        });
      },

      // Clear profile canvas
      clearProfileCanvas() {
        if (this.profileCtx) {
          this.profileCtx.clearRect(0, 0, this.profileCanvas.width, this.profileCanvas.height);
        }
      },

      // Initialize socket connection
      initSocket() {
        console.log("Initializing socket connection...");

        // Basic Socket.IO connection
        this.socket = io({
          path: "/socket.io/",
          transports: ["websocket", "polling"],
          reconnection: true,
          reconnectionAttempts: Infinity,
          reconnectionDelay: 1000,
          reconnectionDelayMax: 5000,
          timeout: 20000,
          autoConnect: false,
          query: {
            room_id: this.roomId,
            client_type: "player",
          },
        });

        // Show that we're connecting
        this.updateConnectionStatus("Connecting to server...");

        // Manually connect
        this.socket.connect();

        // Connection event handlers
        this.socket.on("connect", () => {
          console.log("Socket connected");
          this.updateConnectionStatus("Connected to server");
          this.debugState.socketConnected = true;
          this.updateDebugInfo();
        });

        this.socket.on("connect_error", (error) => {
          console.error("Socket connection error:", error);
          this.updateConnectionStatus("Connection error: " + error.message, true);
          this.debugState.socketConnected = false;
          this.debugState.lastError = {
            time: new Date().toISOString(),
            type: "connect_error",
            message: error.message,
          };
          this.updateDebugInfo();
        });

        this.socket.on("disconnect", (reason) => {
          console.log("Disconnected:", reason);
          this.showNotification("Connection lost. Attempting to reconnect...", "warning");
          this.debugState.socketConnected = false;
          this.debugState.lastError = {
            time: new Date().toISOString(),
            type: "disconnect",
            reason: reason,
          };
          this.updateDebugInfo();

          // If player was already joined, attempt state recovery on reconnect
          if (this.hasJoined) {
            this.socket.once("connect", () => {
              this.socket.emit("recover_state", {
                room_id: this.roomId,
                client_id: this.socket.io.opts.query.client_id,
              });
            });
          }
        });

        // Handle state recovery
        this.socket.on("state_recovered", (state) => {
          console.log("State recovered:", state);
          this.showNotification("Game state recovered!", "success");
          if (state.gameArea) {
            document.getElementById("gameArea").innerHTML = state.gameArea;
          }
        });

        // Listen for join/leave events
        this.socket.on("join_confirmed", (data) => {
          console.log("Join confirmed:", data);
          this.hasJoined = true;
          this.showNotification("Successfully joined the game!");
          this.transitionToGame();
        });

        this.socket.on("join_error", (error) => {
          console.error("Join error:", error);
          this.showNotification(error.message || "Failed to join game", "error");
          this.resetJoinButton();
        });

        this.socket.on("player_joined", (data) => {
          console.log("Player joined:", data);
          // Update player list
          if (data.players) {
            this.updatePlayerList(data.players);
          }
          if (data.new_player) {
            this.showNotification(`${data.new_player} joined the game`, "info");
            if (typeof playSound === "function") {
              playSound("player_join");
            }
          }
        });

        this.socket.on("player_left", (data) => {
          console.log("Player left:", data);
          if (data.players) {
            this.updatePlayerList(data.players);
          }
          if (data.disconnected_player) {
            this.showNotification(`${data.disconnected_player} left the game`, "info");
          }
        });

        // Listen for game flow
        this.setupGameListeners();
      },

      /****************************************
       *            GAME LISTENERS
       ****************************************/
      setupGameListeners() {
        // game_started
        this.socket.on("game_started", (data) => {
          console.log("Game started:", data);
          this.currentGame = data.game_type;

          // Hide name input, show game area
          document.getElementById("nameInput").classList.add("hidden");
          document.getElementById("gameArea").classList.remove("hidden");
          document.getElementById("welcomeScreen").classList.add("hidden");

          // Hide all screens
          document.getElementById("triviaScreen").classList.add("hidden");
          document.getElementById("chaseScreen").classList.add("hidden");
          document.getElementById("drawingScreen").classList.add("hidden");

          // Show the correct screen
          if (data.game_type === "trivia") {
            document.getElementById("triviaScreen").classList.remove("hidden");
            // Populate the question
            document.getElementById("questionText").textContent = data.question.question;
            const options = document.getElementById("answerOptions");
            options.innerHTML = "";
            data.question.options.forEach((option) => {
              const button = document.createElement("button");
              button.className =
                "w-full p-4 text-left bg-white border-2 border-gray-200 rounded-lg hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-indigo-500";
              button.textContent = option;
              // Example of how you'd submit an answer
              button.onclick = () => {
                this.submitAnswer(option);
              };
              options.appendChild(button);
            });
          } else if (data.game_type === "chase") {
            document.getElementById("chaseScreen").classList.remove("hidden");
            this.isChaser = data.is_chaser;
            document.getElementById("chaseRole").textContent = this.isChaser
              ? "You are the Chaser!"
              : "You are the Contestant!";
            document.getElementById("chaseStatus").textContent = `Category: ${data.chase_category}`;
            this.initChaseBoard(data.board_size);
            // Optional: play chase music
            if (typeof playMusic === "function") {
              playMusic("chase");
            }
          } else if (data.game_type === "chinese_whispers") {
            document.getElementById("drawingScreen").classList.remove("hidden");
            this.isDrawer = data.is_drawer;
            if (this.isDrawer) {
              document.getElementById("drawingWord").textContent = `Draw: ${data.word}`;
              document.getElementById("drawingTurn").textContent = "Your turn to draw!";
              this.initDrawingCanvas();
            } else {
              document.getElementById("drawingWord").textContent = "Waiting for drawing...";
              document.getElementById("drawingTurn").textContent =
                "Watch the drawing and guess the word";
            }
          }

          // Start timer if needed
          if (data.time_limit) {
            this.startTimer(data.time_limit);
          }

          // Update scores if available
          if (data.scores) {
            this.updateScores(data.scores);
          }
        });

        // TRIVIA logic placeholders
        this.socket.on("game_state", (data) => {
          console.log("Game state update:", data);
          // This is where you'd handle mid-game updates
        });

        this.socket.on("game_complete", (data) => {
          console.log("Game complete:", data);
          this.showGameResults(data);
        });

        // CHASE game events
        this.socket.on("chase_question", (data) => {
          const questionEl = document.getElementById("chaseQuestion");
          const optionsEl = document.getElementById("chaseOptions");

          questionEl.textContent = data.question;

          optionsEl.innerHTML = "";
          data.options.forEach((option, index) => {
            const button = document.createElement("button");
            button.className =
              "w-full p-4 text-left bg-gray-100 hover:bg-gray-200 rounded-lg transition-colors";
            button.innerHTML = `
              <span
                class="inline-block w-8 h-8 mr-3 text-center leading-8 bg-indigo-100 text-indigo-700 rounded-full font-bold"
              >
                ${String.fromCharCode(65 + index)}
              </span>
              ${option}
            `;
            button.onclick = () => this.submitChaseAnswer(index);
            optionsEl.appendChild(button);
          });

          // Timer
          if (data.time_limit) {
            this.startTimer(data.time_limit);
          }
        });

        this.socket.on("chase_answer_result", (data) => {
          const feedback = document.getElementById("chaseFeedback");
          const correct = feedback.querySelector(".correct-feedback");
          const wrong = feedback.querySelector(".wrong-feedback");
          feedback.classList.remove("hidden");

          if (data.is_correct) {
            correct.classList.remove("hidden");
            wrong.classList.add("hidden");
            // Example of playing correct sound
            if (typeof playSound === "function") {
              playSound("correct");
            }
          } else {
            correct.classList.add("hidden");
            wrong.classList.remove("hidden");
            if (typeof playSound === "function") {
              playSound("wrong");
            }
          }

          // Update chase positions
          this.updateChasePositions(data);

          // Show next question if available
          if (data.next_question) {
            setTimeout(() => {
              feedback.classList.add("hidden");
              // Request next question
              this.socket.emit("ready_for_question", {
                room_id: this.roomId,
              });
            }, 2000);
          }
        });

        this.socket.on("chase_game_over", (data) => {
          this.showGameResults(data);
        });

        // CHINESE WHISPERS
        this.socket.on("receive_drawing", (data) => {
          if (!this.isDrawer) {
            this.displayDrawing(data.drawing);
          }
        });

        this.socket.on("next_player", (data) => {
          document.getElementById("drawingTurn").textContent = `${data.player}'s turn`;
        });

        this.socket.on("round_complete", (data) => {
          this.showFeedback({
            title: "Round Complete!",
            message: `The word was: ${data.original_word}`,
            stats: {
              "Final Guess": data.final_guess,
              "Your Score": data.scores[this.socket.id] || 0,
            },
          });
        });
      },

      /****************************************
       *         GAME ACTION FUNCTIONS
       ****************************************/
      submitAnswer(answer) {
        if (this.hasAnswered) return;
        this.hasAnswered = true;

        // Disable all answer buttons
        const buttons = document.querySelectorAll('#answerOptions button');
        buttons.forEach(button => {
          button.disabled = true;
          button.classList.add('opacity-50', 'cursor-not-allowed');
          if (button.textContent === answer) {
            button.classList.add('bg-indigo-100', 'border-indigo-500');
          }
        });

        // Show waiting message
        document.getElementById('answerStatus').classList.remove('hidden');

        // Emit answer to server
        this.socket.emit("submit_trivia_answer", {
          room_id: this.roomId,
          answer: answer,
          time_remaining: parseInt(document.getElementById("timer").textContent)
        });
      },

      submitChaseAnswer(answerIndex) {
        console.log("Submit chase answer:", answerIndex);
        if (!this.socket) return;
        this.socket.emit("chase_answer", {
          room_id: this.roomId,
          answer: answerIndex,
        });

        // Disable chase option buttons
        const options = document.getElementById("chaseOptions");
        Array.from(options.children).forEach((btn) => {
          btn.disabled = true;
          btn.classList.add("opacity-50");
        });
      },

      updateChasePositions(data) {
        // Clear existing board
        const board = document.getElementById("chaseBoard");
        if (!board) return;

        // Reset all cells to base style
        Array.from(board.children).forEach((cell, idx) => {
          cell.className =
            "aspect-square rounded-lg transition-all duration-300 bg-gray-700";
        });

        // Mark start and end
        if (board.children[0]) {
          board.children[0].className += " bg-red-500";
        }
        if (board.children[board.children.length - 1]) {
          board.children[board.children.length - 1].className += " bg-green-500";
        }

        // Chaser position
        if (data.chaser_position >= 0 && board.children[data.chaser_position]) {
          board.children[data.chaser_position].className =
            "aspect-square rounded-lg transition-all duration-300 bg-red-600";
        }

        // Contestant position
        if (
          data.contestant_position >= 0 &&
          board.children[data.contestant_position]
        ) {
          board.children[data.contestant_position].className =
            "aspect-square rounded-lg transition-all duration-300 bg-blue-500";
        }
      },

      initChaseBoard(size) {
        const board = document.getElementById("chaseBoard");
        if (!board) return;
        board.innerHTML = "";
        board.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

        for (let i = 0; i < size; i++) {
          const cell = document.createElement("div");
          cell.id = `chase-cell-${i}`;
          cell.className =
            "aspect-square rounded-lg transition-all duration-300 bg-gray-700";
          board.appendChild(cell);
        }

        // Mark start and end visually
        if (board.children[0]) {
          board.children[0].className += " bg-red-500";
        }
        if (board.children[size - 1]) {
          board.children[size - 1].className += " bg-green-500";
        }
      },

      /****************************************
       *         TRIVIA HELPER FUNCTIONS
       ****************************************/
      // e.g. updateScores, handle partial updates, etc.
      updateScores(scores) {
  let scoresList = document.getElementById("scoresList");
  if (!scoresList) {
    const gameArea = document.getElementById("gameArea");
    scoresList = document.createElement("div");
    scoresList.id = "scoresList";
    scoresList.className = "fixed top-4 right-4 bg-white p-4 rounded-lg shadow-lg";
    gameArea.appendChild(scoresList);
  }

  scoresList.innerHTML = '<h3 class="font-bold mb-2">Scores</h3>';

  // Now scores keys are socket IDs, we lookup in this.sidMap
  Object.entries(scores)
    .sort(([, a], [, b]) => b - a)
    .forEach(([playerSid, score]) => {
      // Try to find a friendly name
      const friendlyName = this.sidMap[playerSid] || playerSid;

      const div = document.createElement("div");
      div.className = "flex justify-between items-center mb-1";
      div.innerHTML = `
        <span class="mr-4">${friendlyName}</span>
        <span class="font-mono">${score}</span>
      `;
      scoresList.appendChild(div);
    });
},


      /****************************************
       *       CHINESE WHISPERS DRAWING
       ****************************************/
      initDrawingCanvas() {
        const canvas = document.getElementById("drawingCanvas");
        const ctx = canvas.getContext("2d");
        this.isDrawing = false;
        this.lastX = 0;
        this.lastY = 0;
        this.currentTool = 'brush';

        // Adjust canvas size to parent (with ratio)
        const container = canvas.parentElement;
        canvas.width = container.clientWidth;
        canvas.height = container.clientWidth * 0.75;

        // Set initial drawing style
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 4;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Drawing functions
        const draw = (e) => {
          if (!isDrawing) return;
          e.preventDefault();

          // Get correct coordinates whether mouse or touch
          const rect = canvas.getBoundingClientRect();
          const x = ((e.clientX || e.touches[0].clientX) - rect.left) * (canvas.width / rect.width);
          const y = ((e.clientY || e.touches[0].clientY) - rect.top) * (canvas.height / rect.height);

          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(x, y);

          if (currentTool === 'eraser') {
            ctx.save();
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = ctx.lineWidth * 2;
            ctx.stroke();
            ctx.restore();
          } else {
            ctx.stroke();
          }

          [lastX, lastY] = [x, y];

          // Send drawing data to server
          this.socket.emit('drawing_update', {
            type: 'line',
            x1: lastX / canvas.width,
            y1: lastY / canvas.height,
            x2: x / canvas.width,
            y2: y / canvas.height,
            color: ctx.strokeStyle,
            width: ctx.lineWidth,
            tool: currentTool
          });
        };

        // Event listeners for mouse
        canvas.addEventListener("mousedown", (e) => {
          isDrawing = true;
          const rect = canvas.getBoundingClientRect();
          [lastX, lastY] = [
            (e.clientX - rect.left) * (canvas.width / rect.width),
            (e.clientY - rect.top) * (canvas.height / rect.height)
          ];
        });
        canvas.addEventListener("mousemove", draw);
        canvas.addEventListener("mouseup", () => (isDrawing = false));
        canvas.addEventListener("mouseout", () => (isDrawing = false));

        // Event listeners for touch
        canvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          isDrawing = true;
          const rect = canvas.getBoundingClientRect();
          [lastX, lastY] = [
            (e.touches[0].clientX - rect.left) * (canvas.width / rect.width),
            (e.touches[0].clientY - rect.top) * (canvas.height / rect.height)
          ];
        });
        canvas.addEventListener("touchmove", draw);
        canvas.addEventListener("touchend", () => (isDrawing = false));

        // Color picker
        const colorButtons = document.querySelectorAll("[data-color]");
        colorButtons.forEach((button) => {
          button.addEventListener("click", () => {
            ctx.strokeStyle = button.dataset.color;
            currentTool = 'brush';
            // Remove active class from all buttons
            colorButtons.forEach((btn) =>
              btn.classList.remove("ring-2", "ring-offset-2")
            );
            // Add active class to clicked button
            button.classList.add("ring-2", "ring-offset-2");
            
            // Update tool buttons
            document.querySelectorAll('.tool-btn').forEach(btn => 
              btn.classList.remove('bg-gray-100'));
            document.querySelector('[data-tool="brush"]').classList.add('bg-gray-100');
          });
        });

        // Tool buttons
        const toolButtons = document.querySelectorAll(".tool-btn");
        toolButtons.forEach((button) => {
          button.addEventListener("click", () => {
            currentTool = button.dataset.tool;
            // Remove active class from all buttons
            toolButtons.forEach((btn) =>
              btn.classList.remove("bg-gray-100")
            );
            // Add active class to clicked button
            button.classList.add("bg-gray-100");
          });
        });

        // Brush size slider
        const sizeSlider = document.getElementById("brushSize");
        sizeSlider.addEventListener("input", () => {
          ctx.lineWidth = sizeSlider.value;
        });

        // Clear canvas button
        this.clearCanvas = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          this.socket.emit('drawing_update', {
            type: 'clear'
          });
        };

        // Handle incoming drawing updates
        this.socket.on('drawing_update', (data) => {
          if (data.type === 'clear') {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            return;
          }

          ctx.beginPath();
          ctx.moveTo(data.x1 * canvas.width, data.y1 * canvas.height);
          ctx.lineTo(data.x2 * canvas.width, data.y2 * canvas.height);
          
          if (data.tool === 'eraser') {
            ctx.save();
            ctx.strokeStyle = '#FFFFFF';
            ctx.lineWidth = data.width * 2;
            ctx.stroke();
            ctx.restore();
          } else {
            const originalStyle = ctx.strokeStyle;
            const originalWidth = ctx.lineWidth;
            ctx.strokeStyle = data.color;
            ctx.lineWidth = data.width;
            ctx.stroke();
            ctx.strokeStyle = originalStyle;
            ctx.lineWidth = originalWidth;
          }
        });

        // Update internal state
        [lastX, lastY] = [0, 0];
        let lastY = 0;

        // Mouse events
        canvas.addEventListener("mousedown", (e) => {
          isDrawing = true;
          [lastX, lastY] = [e.offsetX, e.offsetY];
        });
        canvas.addEventListener("mousemove", (e) => {
          if (!isDrawing) return;
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(e.offsetX, e.offsetY);
          ctx.stroke();
          [lastX, lastY] = [e.offsetX, e.offsetY];

          // Send partial data to server or some logic
          this.socket.emit("drawing", {
            room_id: this.roomId,
            drawing: canvas.toDataURL(),
          });
        });
        canvas.addEventListener("mouseup", () => (isDrawing = false));
        canvas.addEventListener("mouseout", () => (isDrawing = false));

        // Touch events
        function getTouchPos(e) {
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          return {
            x: touch.clientX - rect.left,
            y: touch.clientY - rect.top,
          };
        }
        canvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          const pos = getTouchPos(e);
          isDrawing = true;
          [lastX, lastY] = [pos.x, pos.y];
        });
        canvas.addEventListener("touchmove", (e) => {
          e.preventDefault();
          if (!isDrawing) return;
          const pos = getTouchPos(e);
          ctx.beginPath();
          ctx.moveTo(lastX, lastY);
          ctx.lineTo(pos.x, pos.y);
          ctx.stroke();
          [lastX, lastY] = [pos.x, pos.y];
          this.socket.emit("drawing", {
            room_id: this.roomId,
            drawing: canvas.toDataURL(),
          });
        });
        canvas.addEventListener("touchend", () => (isDrawing = false));
        canvas.addEventListener("touchcancel", () => (isDrawing = false));

        // Tool interactions
        document.querySelectorAll(".color-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            ctx.strokeStyle = btn.dataset.color;
          });
        });

        document.querySelectorAll(".tool-btn").forEach((btn) => {
          btn.addEventListener("click", () => {
            if (btn.dataset.tool === "brush") {
              ctx.globalCompositeOperation = "source-over";
            } else if (btn.dataset.tool === "eraser") {
              ctx.globalCompositeOperation = "destination-out";
            }
          });
        });
      },

      displayDrawing(drawingData) {
        const canvas = document.getElementById("drawingCanvas");
        const ctx = canvas.getContext("2d");
        const img = new Image();
        img.onload = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        };
        img.src = drawingData;
      },

      /****************************************
       *             TIMER
       ****************************************/
      startTimer(seconds) {
        let timeLeft = seconds;
        const timerEl = document.getElementById("timer");
        const timerBar = document.getElementById("timerBar");
        const totalTime = seconds;
        this.hasAnswered = false;

        // Clear any existing timer
        if (this.timerInterval) {
          clearInterval(this.timerInterval);
        }

        // Update timer every second
        this.timerInterval = setInterval(() => {
          timerEl.textContent = timeLeft + "s";
          const percentage = (timeLeft / totalTime) * 100;
          timerBar.style.width = percentage + "%";
          
          // Change color based on time remaining
          if (percentage > 66) {
            timerBar.classList.remove("bg-yellow-500", "bg-red-500");
            timerBar.classList.add("bg-indigo-600");
          } else if (percentage > 33) {
            timerBar.classList.remove("bg-indigo-600", "bg-red-500");
            timerBar.classList.add("bg-yellow-500");
          } else {
            timerBar.classList.remove("bg-indigo-600", "bg-yellow-500");
            timerBar.classList.add("bg-red-500");
          }
          
          timeLeft--;

          if (timeLeft < 0) {
            clearInterval(this.timerInterval);
            timerEl.textContent = "Time's up!";
            timerBar.style.width = "0%";
            
            // Auto-submit if no answer was given
            if (!this.hasAnswered) {
              this.submitAnswer(null);
            }
          }
        }, 1000);
        const updateTimer = () => {
          const timerElement = document.getElementById("timer");
          if (!timerElement) return;
          timerElement.textContent = timeLeft;

          if (timeLeft <= 5) {
            timerElement.classList.add("text-red-500");
            // If you have a ticking sound, you could play it here
            // if (this.sounds?.tick) this.sounds.tick.play();
          }

          if (timeLeft <= 0) {
            clearInterval(this.timerInterval);
            // if (this.sounds?.timeUp) this.sounds.timeUp.play();
            // Auto-submit or handle time out
          }
          timeLeft--;
        };

        updateTimer();
        this.timerInterval = setInterval(updateTimer, 1000);
      },

      /****************************************
       *        SHOW / HIDE GAME RESULTS
       ****************************************/
      showGameResults(data) {
        // Create results overlay
        const overlay = document.createElement("div");
        overlay.className = "fixed inset-0 bg-black/80 flex items-center justify-center z-50";

        const content = document.createElement("div");
        content.className = "bg-white rounded-xl p-8 max-w-2xl w-11/12 transform transition-all";

        let resultsHTML = `
          <h2 class="text-3xl font-bold text-center mb-6">${
            data.title || "Game Results"
          }</h2>
          <div class="space-y-6">
        `;

        // If it's chase game, example:
        if (this.currentGame === "chase") {
          const isChaser = data.chaser_id === this.socket.id;
          const escaped = data.escaped_players?.includes(this.socket.id);
          resultsHTML += `
            <div class="text-center text-xl mb-4">
              ${
                isChaser
                  ? data.chaser_won
                    ? "You caught all contestants!"
                    : "Some contestants escaped!"
                  : escaped
                  ? "You escaped with your prize money!"
                  : "The Chaser caught you!"
              }
            </div>
            <div class="text-center text-2xl font-bold mb-6">
              ${
                isChaser
                  ? `Caught ${data.caught_count || 0} contestants`
                  : escaped
                  ? `Won ${data.prize_money || 0} points!`
                  : "Better luck next time!"
              }
            </div>
            <div class="grid gap-4">
              ${Object.entries(data.final_scores || {})
                .sort(([, a], [, b]) => b - a)
                .map(
                  ([player, score]) => `
                  <div class="flex justify-between items-center p-3 bg-gray-50 rounded-lg">
                    <span class="font-medium">${player}</span>
                    <span class="text-lg">${score} points</span>
                  </div>
                `
                )
                .join("")}
            </div>
          `;
        }

        // Close out resultsHTML
        resultsHTML += `
          </div>
          <div class="mt-8 flex justify-center">
            <button
              onclick="this.closest('.fixed').remove()"
              class="bg-indigo-600 text-white px-6 py-2 rounded-lg hover:bg-indigo-700 transition-colors"
            >
              Continue
            </button>
          </div>
        `;
        content.innerHTML = resultsHTML;
        overlay.appendChild(content);
        document.body.appendChild(overlay);

        // Example: play a music or sound at game end
        // if (data.chaser_won && typeof playMusic === "function") {
        //   playMusic("game_over");
        // } else if (typeof playMusic === "function") {
        //   playMusic("victory");
        // }
      },

      /****************************************
       *           GENERIC FEEDBACK
       ****************************************/
      showFeedback(data) {
        const feedback = document.getElementById("gameFeedback");
        const title = document.getElementById("feedbackTitle");
        const message = document.getElementById("feedbackMessage");
        const stats = document.getElementById("feedbackStats");
        const button = document.getElementById("feedbackButton");

        title.textContent = data.title;
        message.textContent = data.message;

        stats.innerHTML = "";
        if (data.stats) {
          Object.entries(data.stats).forEach(([key, value]) => {
            const stat = document.createElement("div");
            stat.className = "bg-gray-50 p-3 rounded-lg";
            stat.innerHTML = `
              <div class="text-sm text-gray-500">${key}</div>
              <div class="text-lg font-bold">${value}</div>
            `;
            stats.appendChild(stat);
          });
        }

        feedback.classList.remove("hidden");
        feedback.classList.add("flex");

        button.onclick = () => {
          feedback.classList.add("hidden");
          feedback.classList.remove("flex");
        };
      },

      /****************************************
       *       PROFILE DRAWING (AVATAR)
       ****************************************/
      initProfileDrawing() {
        console.log("Initializing profile drawing");
        const canvas = document.getElementById("profileCanvas");
        if (!canvas) {
          console.error("Canvas element not found");
          this.showStatus("Error initializing drawing canvas", "error");
          return;
        }

        this.profileState = {
          canvas,
          ctx: canvas.getContext("2d"),
          isDrawing: false,
          currentColor: "#000000",
          currentTool: "brush",
          brushSize: 4,
          lastX: 0,
          lastY: 0,
          undoStack: [],
          redoStack: [],
        };

        const ctx = this.profileState.ctx;
        // Fill white by default
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        // Event wiring
        canvas.addEventListener("mousedown", (e) => this.startProfileDrawing(e));
        canvas.addEventListener("mousemove", (e) => this.drawProfile(e));
        canvas.addEventListener("mouseup", () => this.endProfileDrawing());
        canvas.addEventListener("mouseleave", () => this.endProfileDrawing());

        // Touch
        canvas.addEventListener("touchstart", (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          this.startProfileDrawing({ offsetX: x, offsetY: y });
        });
        canvas.addEventListener("touchmove", (e) => {
          e.preventDefault();
          const rect = canvas.getBoundingClientRect();
          const touch = e.touches[0];
          const x = touch.clientX - rect.left;
          const y = touch.clientY - rect.top;
          this.drawProfile({ offsetX: x, offsetY: y });
        });
        canvas.addEventListener("touchend", () => this.endProfileDrawing());
        canvas.addEventListener("touchcancel", () => this.endProfileDrawing());

        // Color picker
        document.querySelectorAll(".color-picker button").forEach((btn) => {
          btn.addEventListener("click", () => {
            this.profileState.currentColor = btn.dataset.color;
            this.updateToolStyles();
          });
        });

        // Tool buttons
        document.querySelectorAll(".tool-btn[data-tool]").forEach((btn) => {
          btn.addEventListener("click", () => {
            this.profileState.currentTool = btn.dataset.tool;
            this.updateToolStyles();
          });
        });

        // Brush size
        const sizeSlider = document.getElementById("profileBrushSize");
        if (sizeSlider) {
          sizeSlider.addEventListener("input", (e) => {
            this.profileState.brushSize = parseInt(e.target.value);
          });
        }

        // Save initial state
        this.saveProfileState();
      },

      startProfileDrawing(e) {
        if (!this.profileState) return;
        this.profileState.isDrawing = true;
        this.profileState.lastX = e.offsetX;
        this.profileState.lastY = e.offsetY;

        const ctx = this.profileState.ctx;
        ctx.beginPath();
        ctx.moveTo(e.offsetX, e.offsetY);
        ctx.arc(
          e.offsetX,
          e.offsetY,
          this.profileState.brushSize / 2,
          0,
          Math.PI * 2
        );
        ctx.fill();

        // Save state for undo
        this.saveProfileState();
      },

      drawProfile(e) {
        if (!this.profileState || !this.profileState.isDrawing) return;

        const { ctx, currentColor, currentTool, brushSize } = this.profileState;
        ctx.lineWidth = brushSize;
        ctx.lineCap = "round";
        ctx.lineJoin = "round";

        if (currentTool === "eraser") {
          ctx.strokeStyle = "#FFFFFF";
          ctx.globalCompositeOperation = "destination-out";
        } else {
          ctx.strokeStyle = currentColor;
          ctx.fillStyle = currentColor;
          ctx.globalCompositeOperation = "source-over";
        }

        ctx.beginPath();
        ctx.moveTo(this.profileState.lastX, this.profileState.lastY);
        ctx.lineTo(e.offsetX, e.offsetY);
        ctx.stroke();

        this.profileState.lastX = e.offsetX;
        this.profileState.lastY = e.offsetY;
      },

      endProfileDrawing() {
        if (!this.profileState) return;
        this.profileState.isDrawing = false;
        this.saveProfileToLocalStorage();
      },

      setProfileColor(color) {
        if (!this.profileState) return;
        this.profileState.currentColor = color;
        this.updateToolStyles();
      },

      setProfileTool(tool) {
        if (!this.profileState) return;
        this.profileState.currentTool = tool;
        this.updateToolStyles();
      },

      setProfileBrushSize(size) {
        if (!this.profileState) return;
        this.profileState.brushSize = size;
      },

      clearProfileCanvas() {
        if (!this.profileState) return;
        const { canvas, ctx } = this.profileState;
        this.saveProfileState(); // For undo
        ctx.fillStyle = "#FFFFFF";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        this.saveProfileToLocalStorage();
      },

      saveProfileState() {
        const { canvas } = this.profileState;
        const imageData = canvas.toDataURL("image/png");
        this.profileState.undoStack.push(imageData);
        // Limit stack
        if (this.profileState.undoStack.length > 10) {
          this.profileState.undoStack.shift();
        }
        // Clear redo stack
        this.profileState.redoStack = [];
      },

      saveProfileToLocalStorage() {
        const { canvas } = this.profileState;
        const imageData = canvas.toDataURL("image/png");
        localStorage.setItem("playerProfile", imageData);
      },

      loadSavedProfile() {
        const savedProfile = localStorage.getItem("playerProfile");
        if (savedProfile && this.profileState) {
          const img = new Image();
          img.onload = () => {
            this.profileState.ctx.drawImage(img, 0, 0);
          };
          img.src = savedProfile;
        }
      },

      updateToolStyles() {
        // Tool highlight
        document.querySelectorAll(".tool-btn[data-tool]").forEach((btn) => {
          btn.classList.toggle(
            "bg-indigo-100",
            btn.dataset.tool === this.profileState.currentTool
          );
        });
        // Color ring
        document.querySelectorAll(".color-picker button").forEach((btn) => {
          btn.classList.toggle(
            "ring-2",
            btn.dataset.color === this.profileState.currentColor
          );
        });
      },

      /****************************************
       *       NAME JOIN & UI HELPERS
       ****************************************/
      async joinGame() {
        console.log("Join game called");
        const playerName = document.getElementById("playerName").value.trim();
        console.log("Attempting to join with name:", playerName);

        if (!playerName) {
          this.showNotification("Please enter your name", "error");
          return;
        }

        if (playerName.length < 2 || playerName.length > 20) {
          this.showNotification("Name must be between 2 and 20 characters", "error");
          return;
        }

        this.debugState.joinAttempts++;
        this.updateDebugInfo();

        const joinButton = document.getElementById("joinButton");
        if (joinButton) {
          joinButton.disabled = true;
          joinButton.querySelector(".join-text").textContent = "Joining...";
          joinButton.querySelector(".loading-spinner").classList.remove("hidden");
        }

        try {
          // Ensure socket is connected
          if (!this.socket.connected) {
            console.log("Socket not connected, attempting to connect...");
            this.showNotification("Connecting to server...", "info");
            await new Promise((resolve, reject) => {
              this.socket.connect();
              this.socket.once("connect", resolve);
              this.socket.once("connect_error", (err) => reject(err));
              setTimeout(() => reject(new Error("Connection timeout")), 5000);
            });
          }

          // Get profile data
          let profileData = null;
          if (this.profileState && this.profileState.canvas) {
            profileData = this.profileState.canvas.toDataURL("image/png", 0.8);
            const hasDrawing = await this.validateProfilePicture(profileData);
            if (!hasDrawing) {
              console.log("No drawing found, generating default profile...");
              // Generate default
              const defaultProfile = await this.generateDefaultProfile(
                playerName[0].toUpperCase()
              );
              this.profileState.ctx.drawImage(defaultProfile, 0, 0);
              profileData = this.profileState.canvas.toDataURL("image/png", 0.8);
            }
            this.saveProfileToLocalStorage();
          } else {
            console.warn("Profile state or canvas not initialized, generating default...");
            const defaultProfile = await this.generateDefaultProfile(
              playerName[0].toUpperCase()
            );
            profileData = defaultProfile.toDataURL("image/png", 0.8);
          }

          this.showNotification("Joining game...", "info");
          this.socket.emit("join_room", {
            room_id: this.roomId,
            player_name: playerName,
            profile_picture: profileData,
            is_host: false,
            client_id: this.socket.id,
          });

          // Set up a timeout in case the server doesn't respond
          const joinTimeout = setTimeout(() => {
            console.error("Join room timeout");
            this.showNotification("Connection timeout. Please try again.", "error");
            this.resetJoinButton();
          }, 10000);

          await new Promise((resolve, reject) => {
            this.socket.once("join_confirmed", () => {
              clearTimeout(joinTimeout);
              resolve();
            });
            this.socket.once("join_error", (err) => {
              clearTimeout(joinTimeout);
              reject(new Error(err.message || "Failed to join game"));
            });
          });
        } catch (error) {
          console.error("Error joining game:", error);
          this.showNotification(error.message || "Failed to join game. Please try again.", "error");
          this.resetJoinButton();

          // Record debug
          this.debugState.lastError = {
            time: new Date().toISOString(),
            type: "join_error",
            message: error.message,
          };
          this.updateDebugInfo();

          // Retry if connection issue
          if (
            error.message.includes("Connection timeout") ||
            error.message.includes("connect")
          ) {
            this.socket.disconnect();
            setTimeout(() => {
              this.socket.connect();
            }, 1000);
          }
        }
      },

      resetJoinButton() {
        const joinButton = document.getElementById("joinButton");
        if (joinButton) {
          joinButton.disabled = false;
          joinButton.querySelector(".join-text").textContent = "Join Game";
          joinButton.querySelector(".loading-spinner").classList.add("hidden");
        }
      },

      async validateProfilePicture(profileData) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);

            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            let hasDrawing = false;
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const a = data[i + 3];
              if (a > 0 && (r !== 255 || g !== 255 || b !== 255)) {
                hasDrawing = true;
                break;
              }
            }
            resolve(hasDrawing);
          };
          img.src = profileData;
        });
      },

      async generateDefaultProfile(letter) {
        const canvas = document.createElement("canvas");
        canvas.width = 128;
        canvas.height = 128;
        const ctx = canvas.getContext("2d");

        // Random pastel
        const hue = Math.random() * 360;
        const saturation = 70 + Math.random() * 10;
        const lightness = 75 + Math.random() * 10;
        const bgColor = `hsl(${hue}, ${saturation}%, ${lightness}%)`;

        // Circle background
        ctx.fillStyle = bgColor;
        ctx.beginPath();
        ctx.arc(64, 64, 64, 0, Math.PI * 2);
        ctx.fill();

        // Letter
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "bold 64px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(letter, 64, 64);

        return canvas;
      },

      /****************************************
       *       PLAYER LIST, UI, AND MISC
       ****************************************/
      updatePlayerList(players) {
        const playerList = document.getElementById("playerList");
        if (!playerList) return;
        playerList.innerHTML = "";

        players.forEach((player) => {
          const div = document.createElement("div");
          div.className = "flex justify-between items-center p-2 bg-white rounded-lg shadow-sm";
          div.innerHTML = `
            <div class="flex items-center space-x-2">
              <div class="w-8 h-8 rounded-full bg-indigo-100 flex items-center justify-center">
                <span class="text-indigo-600 font-medium">${player.name[0]?.toUpperCase() || "?"}</span>
              </div>
              <span class="font-medium">${player.name}</span>
            </div>
            <div class="flex items-center space-x-2">
              <span class="text-gray-500">${player.score || 0} points</span>
              ${
                player.is_chaser
                  ? '<span class="text-red-500">(Chaser)</span>'
                  : ""
              }
            </div>
          `;
          playerList.appendChild(div);
        });
      },

      transitionToGame() {
        const nameInput = document.getElementById("nameInput");
        const gameArea = document.getElementById("gameArea");

        if (nameInput && gameArea) {
          nameInput.style.opacity = "0";
          nameInput.style.transition = "opacity 0.5s ease-out";

          setTimeout(() => {
            nameInput.classList.add("hidden");
            gameArea.classList.remove("hidden");
            gameArea.style.opacity = "0";
            requestAnimationFrame(() => {
              gameArea.style.transition = "opacity 0.5s ease-in";
              gameArea.style.opacity = "1";
            });
          }, 500);
        }
      },

      updateConnectionStatus(status, isError = false) {
        const statusEl = document.getElementById("connectionStatus");
        if (statusEl) {
          statusEl.textContent = status;
          statusEl.className = `text-sm ${
            isError ? "text-red-600" : "text-gray-600"
          } mb-4 transition-all`;
        }
      },

      showNotification(message, type = "info") {
        const toast = document.getElementById("connectionToast");
        const toastText = document.getElementById("connectionToastText");

        if (toast && toastText) {
          toastText.textContent = message;
          toast.className = `fixed bottom-4 left-1/2 transform -translate-x-1/2 px-4 py-2 rounded-full text-sm z-50 ${
            type === "error" ? "bg-red-600 text-white" : "bg-black/80 text-white"
          }`;
          toast.classList.remove("hidden");

          setTimeout(() => {
            toast.classList.add("hidden");
          }, 3000);
        }
      },

      showStatus(message, type = "info") {
        // Helper for quick messages
        const statusContainer = document.getElementById("statusMessages");
        const status = document.createElement("div");
        status.className = `p-3 rounded-lg shadow-lg text-sm transition-all transform translate-y-2 ${
          type === "error"
            ? "bg-red-500 text-white"
            : type === "success"
            ? "bg-green-500 text-white"
            : "bg-black/80 text-white"
        }`;
        status.textContent = message;
        statusContainer.appendChild(status);

        requestAnimationFrame(() => {
          status.style.transform = "translateY(0)";
        });

        setTimeout(() => {
          status.style.opacity = "0";
          setTimeout(() => status.remove(), 300);
        }, 3000);
      },

      /****************************************
       *          DEBUG OVERLAY
       ****************************************/
      toggleDebug() {
        const overlay = document.getElementById("debugOverlay");
        this.debugVisible = !this.debugVisible;
        if (overlay) {
          overlay.classList.toggle("hidden", !this.debugVisible);
          if (this.debugVisible) {
            this.updateDebugInfo();
          }
        }
      },

      updateDebugInfo() {
        const debugInfo = document.getElementById("debugInfo");
        if (!debugInfo) return;
        debugInfo.textContent = JSON.stringify(
          {
            roomId: this.roomId,
            socketConnected: this.debugState.socketConnected,
            hasJoined: this.hasJoined,
            joinAttempts: this.debugState.joinAttempts,
            lastError: this.debugState.lastError,
            events: this.debugState.events,
          },
          null,
          2
        );
      },

      addKeyboardListeners() {
        // Ctrl+Shift+D => debug overlay
        document.addEventListener("keydown", (e) => {
          if (e.ctrlKey && e.shiftKey && e.key === "D") {
            this.toggleDebug();
          }
        });

        // Enter to join
        const playerNameInput = document.getElementById("playerName");
        if (playerNameInput) {
          playerNameInput.addEventListener("keypress", (e) => {
            if (e.key === "Enter") {
              this.joinGame();
            }
          });
        }
      },
    };

    // Attach to window for debugging
    window.gameState = gameState;

    // Initialize on DOMContentLoaded
    document.addEventListener("DOMContentLoaded", () => {
      console.log("DOM loaded, initializing game...");
      try {
        window.gameState.init();
        console.log("Game initialized successfully");
      } catch (error) {
        console.error("Error initializing game:", error);
      }
    });

    // Example function for the "trash" button in the drawing screen (Chinese Whispers)
    function clearCanvas() {
      const canvas = document.getElementById("drawingCanvas");
      if (!canvas) return;
      const ctx = canvas.getContext("2d");
      ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  </script>
</body>
</html>
